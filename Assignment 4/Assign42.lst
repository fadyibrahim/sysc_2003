WARNING: EXTCODE CODE AREA DO NOT CONTAIN RELOCATED ADDRESSES.
THIS WILL BE REMEDIED IN A LATER RELEASE.
                        .module Assign42.C
 0000            REGBS = $0000 ; DP256 register bank base address
 0000            PORTA = REGBS+0 ;port A = Address lines A8 A15
 0001            PORTB = REGBS+1 ;port B = Address lines A0 A7
 0002            DDRA = REGBS+2 ;port A direction register
 0003            DDRB = REGBS+3 ;port A direction register
 0008            PORTE = REGBS+8 ;port E = mode,IRQandcontrolsignals
 0009            DDRE = REGBS+9 ;port E direction register
 000A            PEAR = REGBS+$A ;port E assignments
 000B            MODE = REGBS+$B ;Mode register
 000C            PUCR = REGBS+$C ;port pull-up control register
 000D            RDRIV = REGBS+$D ;port reduced drive control register
 000E            EBICTL = REGBS+$E ;E stretch control
--- 0000           
 0010            INITRM = REGBS+$10 ;Ram location register
 0011            INITRG = REGBS+$11 ;Register location register
 0012            INITEE = REGBS+$12 ;EEprom location register
 0013            MISC = REGBS+$13 ;MiscellaneoMapping control
 0014            MTST0 = REGBS+$14 ; RESERVED
 0015            ITCR = REGBS+$15 ;Interrupt test control register
 0016            ITEST = REGBS+$16 ;Interrupt test register
 0017            MTST1 = REGBS+$17 ; Reserved
--- 0000           
 001A            PARTIDH = REGBS+$1A ;Part ID high
 001B            PARTIDL = REGBS+$1B ;Part ID low
 001C            MEMSIZ0 = REGBS+$1C ;memory size
 001D            MEMSIZ1 = REGBS+$1D ;memory size
 001E            INTCR = REGBS+$1E ;interrupt control register
 001F            HPRIO = REGBS+$1F ;high priority reg
--- 0000           
 0028            BKPCT0 = REGBS+$28 ;Break control register
 0029            BKPCT1 = REGBS+$29 ;Break control register
 002A            BKP0X = REGBS+$2A ; Break 0 index register
 002B            BKP0H = REGBS+$2B ; Break 0 pointer high
 002C            BRP0L = REGBS+$2C ; Break 0 pointer low
 002D            BKP1X = REGBS+$2D ; Break 1 index register
 002E            BKP1H = REGBS+$2E ; Break 1 pointer high
 002F            BRP1L = REGBS+$2F ; Break 1 pointer low
 0030            PPAGE = REGBS+$30 ;Program Page register
--- 0000           
 0032            PORTK = REGBS+$32 ;Port K data
 0033            DDRK = REGBS+$33 ;Port K direction
 0034            SYNR = REGBS+$34 ; Synthesizer / multiplier register
 0035            REFDV = REGBS+$35 ; Reference divider register
 0036            CTFLG = REGBS+$36 ; RESERVED
 0037            CRGFLG = REGBS+$37 ; PLL flags register
 0038            CRGINT = REGBS+$38 ; PLL interrupt register
 0039            CLKSEL = REGBS+$39 ; Clock select register
 003A            PLLCTL = REGBS+$3A ; PLL control register
 003B            RTICTL = REGBS+$3B ;Real time interrupt control
 003C            COPCTL = REGBS+$3C ;Watchdog control
 003D            FORBYP = REGBS+$3D ;
 003E            CTCTL = REGBS+$3E ;
 003F            ARMCOP = REGBS+$3F ;COP reset register
--- 0000           
 0040            TIOS = REGBS+$40 ;timer input/output select
 0041            CFORC = REGBS+$41 ;timer compare force
 0042            OC7M = REGBS+$42 ;timer output compare 7 mask
 0043            OC7D = REGBS+$43 ;timer output compare 7 data
 0044            TCNT = REGBS+$44 ;timer counter register hi
 0045            *TCNT = REGBS+$45 ;timer counter register lo
 0046            TSCR = REGBS+$46 ;timer system control register
 0047            TTOV = REGBS+$47 ;reserved
 0048            TCTL1 = REGBS+$48 ;timer control register 1
 0049            TCTL2 = REGBS+$49 ;timer control register 2
 004A            TCTL3 = REGBS+$4A ;timer control register 3
 004B            TCTL4 = REGBS+$4B ;timer control register 4
 004C            TMSK1 = REGBS+$4C ;timer interrupt mask 1
 004D            TMSK2 = REGBS+$4D ;timer interrupt mask 2
 004E            TFLG1 = REGBS+$4E ;timer flags 1
 004F            TFLG2 = REGBS+$4F ;timer flags 2
 0050            TC0 = REGBS+$50 ;timer capture/comparregister 0
 0051            *TC0 = REGBS+$51 ;
 0052            TC1 = REGBS+$52 ;timer capture/comparregister 1
 0053            *TC1 = REGBS+$53 ;
 0054            TC2 = REGBS+$54 ;timer capture/comparregister 2
 0055            *TC2 = REGBS+$55 ;
 0056            TC3 = REGBS+$56 ;timer capture/comparregister 3
 0057            *TC3 = REGBS+$57 ;
 0058            TC4 = REGBS+$58 ;timer capture/comparregister 4
 0059            *TC4 = REGBS+$59 ;
 005A            TC5 = REGBS+$5A ;timer capture/comparregister 5
 005B            *TC5 = REGBS+$5B ;
 005C            TC6 = REGBS+$5C ;timer capture/comparregister 6
 005D            *TC6 = REGBS+$5D ;
 005E            TC7 = REGBS+$5E ;timer capture/comparregister 7
 005F            *TC7 = REGBS+$5F ;
 0060            PACTL = REGBS+$60 ;pulse accumulator controls
 0061            PAFLG = REGBS+$61 ;pulse accumulator flags
 0062            PACN3 = REGBS+$62 ;pulse accumulator counter 3
 0063            PACN2 = REGBS+$63 ;pulse accumulator counter 2
 0064            PACN1 = REGBS+$64 ;pulse accumulator counter 1
 0065            PACN0 = REGBS+$65 ;pulse accumulator counter 0
 0066            MCCTL = REGBS+$66 ;Modulus down conunter control
 0067            MCFLG = REGBS+$67 ;down counter flags
 0068            ICPAR = REGBS+$68 ;Input pulse accumulatocontrol
 0069            DLYCT = REGBS+$69 ;Delay count to down counter
 006A            ICOVW = REGBS+$6A ;Input control overwrite register
 006B            ICSYS = REGBS+$6B ;Input control system control
--- 0000           
 006D            TIMTST = REGBS+$6D ;timer test register
--- 0000           
 0070            PBCTL = REGBS+$70 ; Pulse accumulatoB control
 0071            PBFLG = REGBS+$71 ; Pulse accumulatoB flags
 0072            PA3H = REGBS+$72 ; Pulse Accumulatoholding regist3
 0073            PA2H = REGBS+$73 ; Pulse Accumulatoholding regist2
 0074            PA1H = REGBS+$74 ; Pulse Accumulatoholding regist1
 0075            PA0H = REGBS+$75 ; Pulse Accumulatoholding regist0
 0076            MCCNT = REGBS+$76 ; Modulus down counter register
 0077            *MCCNTL = REGBS+$77 ; low byte
 0078            TCOH = REGBS+$78 ; Capture 0 holding register
 007A            TC1H = REGBS+$7A ; Capture 1 holding register
 007C            TC2H = REGBS+$7C ; Capture 2 holding register
 007E            TC3H = REGBS+$7E ; Capture 3 holding register
--- 0000           
 0080            ATD0CTL0 = REGBS+$80 ;ADC control 0 (reserved)
 0081            ATD0CTL1 = REGBS+$81 ;ADC control 1 (reserved)
 0082            ATD0CTL2 = REGBS+$82 ;ADC control 2
 0083            ATD0CTL3 = REGBS+$83 ;ADC control 3
 0084            ATD0CTL4 = REGBS+$84 ;ADC control 4
 0085            ATD0CTL5 = REGBS+$85 ;ADC control 5
 0086            ATD0STAT = REGBS+$86 ;ADC status register hi
 0087            *ATD0STAT = REGBS+$87 ;ADC status register lo
 0088            ATD0TEST = REGBS+$88 ;ADC test (reserved)
 0089            *ATD0TEST = REGBS+$89 ;
--- 0000           
 008D            ATD0DIEN = REGBS+$8D ;
--- 0000           
 008F            PORTAD = REGBS+$8F ;port ADC = input only
 0090            ADR00H = REGBS+$90 ;ADC result 0 register
 0092            ADR01H = REGBS+$92 ;ADC result 1 register
 0094            ADR02H = REGBS+$94 ;ADC result 2 register
 0096            ADR03H = REGBS+$96 ;ADC result 3 register
 0098            ADR04H = REGBS+$98 ;ADC result 4 register
 009A            ADR05H = REGBS+$9A ;ADC result 5 register
 009C            ADR06H = REGBS+$9C ;ADC result 6 register
 009E            ADR07H = REGBS+$9E ;ADC result 7 register
--- 0000           
 00A0            PWME = REGBS+$A0 ;PWM enable
 00A1            PWMPOL = REGBS+$A1 ;PWM polarity
 00A2            PWMCLK = REGBS+$A2 ;PWM clock select register
 00A3            PWMPRCLK = REGBS+$A3 ;PWM Prescale clock select register
 00A4            PWMCAE = REGBS+$A4 ;PWM center align select register
 00A5            PWMCTL = REGBS+$A5 ;PWM control register
 00A6            PWMTST = REGBS+$A6 ;reserved
 00A7            PWMPRSC = REGBS+$A7 ;reserved
 00A8            PWMSCLA = REGBS+$A8 ;PWM Scale A
 00A9            PWMSCLB = REGBS+$A9 ;PWM scale B
 00AA            PWMSCNTA = REGBS+$AA ;reserved
 00AB            PWMSCNTB = REGBS+$AB ;reserved
 00AC            PWMCNT0 = REGBS+$AC ;PWM channel 0 counter
 00AD            PWMCNT1 = REGBS+$AD ;PWM channel 1 counter
 00AE            PWMCNT2 = REGBS+$AE ;PWM channel 2 counter
 00AF            PWMCNT3 = REGBS+$AF ;PWM channel 3 counter
 00B0            PWMCNT4 = REGBS+$B0 ;PWM channel 4 counter
 00B1            PWMCNT5 = REGBS+$B1 ;PWM channel 5 counter
 00B2            PWMCNT6 = REGBS+$B2 ;PWM channel 6 counter
 00B3            PWMCNT7 = REGBS+$B3 ;PWM channel 7 counter
 00B4            PWMPER0 = REGBS+$B4 ;PWM channel 0 period
 00B5            PWMPER1 = REGBS+$B5 ;PWM channel 1 period
 00B6            PWMPER2 = REGBS+$B6 ;PWM channel 2 period
 00B7            PWMPER3 = REGBS+$B7 ;PWM channel 3 period
 00B8            PWMPER4 = REGBS+$B8 ;PWM channel 4 period
 00B9            PWMPER5 = REGBS+$B9 ;PWM channel 5 period
 00BA            PWMPER6 = REGBS+$BA ;PWM channel 6 period
 00BB            PWMPER7 = REGBS+$BB ;PWM channel 7 period
 00BC            PWMDTY0 = REGBS+$BC ;PWM channel 0 duty cycle
 00BD            PWMDTY1 = REGBS+$BD ;PWM channel 1 duty cycle
 00BE            PWMDTY2 = REGBS+$BE ;PWM channel 2 duty cycle
 00BF            PWMDTY3 = REGBS+$BF ;PWM channel 3 duty cycle
 00C0            PWMDTY4 = REGBS+$C0 ;PWM channel 0 duty cycle
 00C1            PWMDTY5 = REGBS+$C1 ;PWM channel 1 duty cycle
 00C2            PWMDTY6 = REGBS+$C2 ;PWM channel 2 duty cycle
 00C3            PWMDTY7 = REGBS+$C3 ;PWM channel 3 duty cycle
 00C4            PWMSDN = REGBS+$C4 ;PWM shutdown register
--- 0000           
 00C8            SC0BDH = REGBS+$C8 ;sci 0 baud reg hi byte
 00C9            SC0BDL = REGBS+$C9 ;sci 0 baud reg lo byte
 00CA            SC0CR1 = REGBS+$CA ;sci 0 control1 reg
 00CB            SC0CR2 = REGBS+$CB ;sci 0 control2 reg
 00CC            SC0SR1 = REGBS+$CC ;sci 0 status reg 1
 00CD            SC0SR2 = REGBS+$CD ;sci 0 status reg 2
 00CE            SC0DRH = REGBS+$CE ;sci 0 data reg hi
 00CF            SC0DRL = REGBS+$CF ;sci 0 data reg lo
 00D0            SC1BDH = REGBS+$D0 ;sci 1 baud reg hi byte
 00D1            SC1BDL = REGBS+$D1 ;sci 1 baud reg lo byte
 00D2            SC1CR1 = REGBS+$D2 ;sci 1 control1 reg
 00D3            SC1CR2 = REGBS+$D3 ;sci 1 control2 reg
 00D4            SC1SR1 = REGBS+$D4 ;sci 1 status reg 1
 00D5            SC1SR2 = REGBS+$D5 ;sci 1 status reg 2
 00D6            SC1DRH = REGBS+$D6 ;sci 1 data reg hi
 00D7            SC1DRL = REGBS+$D7 ;sci 1 data reg lo
 00D8            SPI0CR1 = REGBS+$D8 ;spi 0 control1 reg
 00D9            SPI0CR2 = REGBS+$D9 ;spi 0 control2 reg
 00DA            SPI0BR = REGBS+$DA ;spi 0 baud reg
 00DB            SPI0SR = REGBS+$DB ;spi 0 status reg hi
--- 0000           
 00DD            SP0DR = REGBS+$DD ;spi 0 data reg
--- 0000           
 00E0            IBAD = REGBS+$E0 ;I2C Bus address register
 00E1            IBFD = REGBS+$E1 ;I2C Bus fr=ency divider
 00E2            IBCR = REGBS+$E2 ;I2C Bus control register
 00E3            IBSR = REGBS+$E3 ;I2C Bus status register
 00E4            IBDR = REGBS+$E4 ;I2C Bus message data register
--- 0000           
 00E8            DLCBCR1 = REGBS+$E8 ;BDLC Control regsiter 1
 00E9            DLCBSVR = REGBS+$E9 ;BDLC State vector register
 00EA            DLCBCR2 = REGBS+$EA ;BDLC Control register 2
 00EB            DLCBDR = REGBS+$EB ;BDLC Data register
 00EC            DLCBARD = REGBS+$EC ;BDLC Analog delay register
 00ED            DLCBRSR = REGBS+$ED ;BDLC Rate select register
 00EE            DLCSCR = REGBS+$EE ;BDLC Control register
 00EF            DLCBSTAT = REGBS+$EF ;BDLC Status register
 00F0            SPI1CR1 = REGBS+$F0 ;spi 1 control1 reg
 00F1            SPI1CR2 = REGBS+$F1 ;spi 1 control2 reg
 00F2            SPI1BR = REGBS+$F2 ;spi 1 baud reg
 00F3            SPI1SR = REGBS+$F3 ;spi 1 status reg hi
--- 0000           
 00F5            SP1DR = REGBS+$F5 ;spi 1 data reg
--- 0000           
 00F8            SPI2CR1 = REGBS+$F8 ;spi 2 control1 reg
 00F9            SPI2CR2 = REGBS+$F9 ;spi 2 control2 reg
 00FA            SPI2BR = REGBS+$FA ;spi 2 baud reg
 00FB            SPI2SR = REGBS+$FB ;spi 2 status reg hi
--- 0000           
 00FD            SP2DR = REGBS+$FD ;spi 2 data reg
--- 0000           
 0100            FCLKDIV = REGBS+$100 ;FLASH clock divider
 0101            FSEC = REGBS+$101 ;FLASH security register
--- 0000           
 0103            FCNFG = REGBS+$103 ;FLASH configuration register
 0104            FPROT = REGBS+$104 ;FLASH protection register
 0105            FSTAT = REGBS+$105 ;FLASH status register
 0106            FCMD = REGBS+$106 ;FLASH command register
--- 0000           
 0110            ECLKDIV = REGBS+$110 ;EEPROM clock divider
--- 0000           
 0113            ECNFG = REGBS+$113 ;EEPROM configuration register
 0114            EPROT = REGBS+$114 ;EEPROM protection register
 0115            ESTAT = REGBS+$115 ;EEPROM status register
 0116            ECMD = REGBS+$116 ;EEPROM command register
--- 0000           
 0120            ATD1CTL0 = REGBS+$120 ;ADC1 control 0 (reserved)
 0121            ATD1CTL1 = REGBS+$121 ;ADC1 control 1 (reserved)
 0122            ATD1CTL2 = REGBS+$122 ;ADC1 control 2
 0123            ATD1CTL3 = REGBS+$123 ;ADC1 control 3
 0124            ATD1CTL4 = REGBS+$124 ;ADC1 control 4
 0125            ATD1CTL5 = REGBS+$125 ;ADC1 control 5
 0126            ATD1STAT = REGBS+$126 ;ADC1 status register hi
 0127            *ATD1STAT = REGBS+$127 ;ADC1 status register lo
 0128            ATD1TEST = REGBS+$128 ;ADC1 test (reserved)
 0129            *ATD1TEST = REGBS+$129 ;
--- 0000           
 012D            ATDDIEN = REGBS+$12D ;ADC1 INPUT ENABLE REGISTER
--- 0000           
 012F            PORTAD1 = REGBS+$12F ;port ADC1 = input only
 0130            ADR10H = REGBS+$130 ;ADC1 result 0 register
 0132            ADR11H = REGBS+$132 ;ADC1 result 1 register
 0134            ADR12H = REGBS+$134 ;ADC1 result 2 register
 0136            ADR13H = REGBS+$136 ;ADC1 result 3 register
 0138            ADR14H = REGBS+$138 ;ADC1 result 4 register
 013A            ADR15H = REGBS+$13A ;ADC1 result 5 register
 013C            ADR16H = REGBS+$13C ;ADC1 result 6 register
 013E            ADR17H = REGBS+$13E ;ADC1 result 7 register
 0140            CAN0CTL0 = REGBS+$140 ;CAN0 control register 0
 0141            CAN0CTL1 = REGBS+$141 ;CAN0 control register 1
 0142            CAN0BTR0 = REGBS+$142 ;CAN0 bus timing register 0
 0143            CAN0BTR1 = REGBS+$143 ;CAN0 bus timing register 1
 0144            CAN0RFLG = REGBS+$144 ;CAN0 receiver flags
 0145            CAN0RIER = REGBS+$145 ;CAN0 receiver interrupt enables
 0146            CAN0TFLG = REGBS+$146 ;CAN0 transmit flags
 0147            CAN0TIER = REGBS+$147 ;CAN0 transmit interrupt enables
 0148            CAN0TARQ = REGBS+$148 ;CAN0 transmit message abort control
 0149            CAN0TAAK = REGBS+$149 ;CAN0 transmit message abort status
 014A            CAN0TBEL = REGBS+$14A ;CAN0 transmit buffer select
 014B            CAN0IDAC = REGBS+$14B ;CAN0 identfier acceptancecontrol
--- 0000           
 014E            CAN0RERR = REGBS+$14E ;CAN0 Receive error counter
 014F            CAN0TERR = REGBS+$14F ;CAN0 Transmit error counter
 0150            CAN0IDA0 = REGBS+$150 ;CAN0 Identifier acceptanceregister 0
 0151            CAN0IDA1 = REGBS+$151 ;CAN0 Identifier acceptanceregister 1
 0152            CAN0IDA2 = REGBS+$152 ;CAN0 Identifier acceptanceregister 2
 0153            CAN0IDA3 = REGBS+$153 ;CAN0 Identifier acceptanceregister 3
 0154            CAN0IDM0 = REGBS+$154 ;CAN0 Identifier mask register 0
 0155            CAN0IDM1 = REGBS+$155 ;CAN0 Identifier mask register 1
 0156            CAN0IDM2 = REGBS+$156 ;CAN0 Identifier mask register 2
 0157            CAN0IDM3 = REGBS+$157 ;CAN0 Identifier mask register 3
 0158            CAN0IDA4 = REGBS+$158 ;CAN0 Identifier acceptanceregister 4
 0159            CAN0IDA5 = REGBS+$159 ;CAN0 Identifier acceptanceregister 5
 015A            CAN0IDA6 = REGBS+$15A ;CAN0 Identifier acceptanceregister 6
 015B            CAN0IDA7 = REGBS+$15B ;CAN0 Identifier acceptanceregister 7
 015C            CAN0IDM4 = REGBS+$15C ;CAN0 Identifier mask register 4
 015D            CAN0IDM5 = REGBS+$15D ;CAN0 Identifier mask register 5
 015E            CAN0IDM6 = REGBS+$15E ;CAN0 Identifier mask register 6
 015F            CAN0IDM7 = REGBS+$15F ;CAN0 Identifier mask register 7
 0160            CAN0RXFG = REGBS+$160 ;CAN0 RX foregroundbuffer thru +$16F
 0170            CAN0TXFG = REGBS+$170 ;CAN0 TX foregroundbuffer thru +$17F
--- 0000           
 0180            CAN1CTL0 = REGBS+$180 ;CAN1 control register 0
 0181            CAN1CTL1 = REGBS+$181 ;CAN1 control register 1
 0182            CAN1BTR0 = REGBS+$182 ;CAN1 bus timing register 0
 0183            CAN1BTR1 = REGBS+$183 ;CAN1 bus timing register 1
 0184            CAN1RFLG = REGBS+$184 ;CAN1 receiver flags
 0185            CAN1RIER = REGBS+$185 ;CAN1 receiver interrupt enables
 0186            CAN1TFLG = REGBS+$186 ;CAN1 transmit flags
 0187            CAN1TIER = REGBS+$187 ;CAN1 transmit interrupt enables
 0188            CAN1TARQ = REGBS+$188 ;CAN1 transmit message abort control
 0189            CAN1TAAK = REGBS+$189 ;CAN1 transmit message abort status
 018A            CAN1TBEL = REGBS+$18A ;CAN1 transmit buffer select
 018B            CAN1IDAC = REGBS+$18B ;CAN1 identfier acceptancecontrol
--- 0000           
 018E            CAN1RERR = REGBS+$18E ;CAN1 Receive error counter
 018F            CAN1TERR = REGBS+$18F ;CAN1 Transmit error counter
 0190            CAN1IDA0 = REGBS+$190 ;CAN1 Identifier acceptanceregister 0
 0191            CAN1IDA1 = REGBS+$191 ;CAN1 Identifier acceptanceregister 1
 0192            CAN1IDA2 = REGBS+$192 ;CAN1 Identifier acceptanceregister 2
 0193            CAN1IDA3 = REGBS+$193 ;CAN1 Identifier acceptanceregister 3
 0194            CAN1IDM0 = REGBS+$194 ;CAN1 Identifier mask register 0
 0195            CAN1IDM1 = REGBS+$195 ;CAN1 Identifier mask register 1
 0196            CAN1IDM2 = REGBS+$196 ;CAN1 Identifier mask register 2
 0197            CAN1IDM3 = REGBS+$197 ;CAN1 Identifier mask register 3
 0198            CAN1IDA4 = REGBS+$198 ;CAN1 Identifier acceptanceregister 4
 0199            CAN1IDA5 = REGBS+$199 ;CAN1 Identifier acceptanceregister 5
 019A            CAN1IDA6 = REGBS+$19A ;CAN1 Identifier acceptanceregister 6
 019B            CAN1IDA7 = REGBS+$19B ;CAN1 Identifier acceptanceregister 7
 019C            CAN1IDM4 = REGBS+$19C ;CAN1 Identifier mask register 4
 019D            CAN1IDM5 = REGBS+$19D ;CAN1 Identifier mask register 5
 019E            CAN1IDM6 = REGBS+$19E ;CAN1 Identifier mask register 6
 019F            CAN1IDM7 = REGBS+$19F ;CAN1 Identifier mask register 7
 01A0            CAN1RXFG = REGBS+$1A0 ;CAN1 RX foregroundbuffer thru +$1AF
 01B0            CAN1TXFG = REGBS+$1B0 ;CAN1 TX foregroundbuffer thru +$1BF
--- 0000           
 01C0            CAN2CTL0 = REGBS+$1C0 ;CAN2 control register 0
 01C1            CAN2CTL1 = REGBS+$1C1 ;CAN2 control register 1
 01C2            CAN2BTR0 = REGBS+$1C2 ;CAN2 bus timing register 0
 01C3            CAN2BTR1 = REGBS+$1C3 ;CAN2 bus timing register 1
 01C4            CAN2RFLG = REGBS+$1C4 ;CAN2 receiver flags
 01C5            CAN2RIER = REGBS+$1C5 ;CAN2 receiver interrupt enables
 01C6            CAN2TFLG = REGBS+$1C6 ;CAN2 transmit flags
 01C7            CAN2TIER = REGBS+$1C7 ;CAN2 transmit interrupt enables
 01C8            CAN2TARQ = REGBS+$1C8 ;CAN2 transmit message abort control
 01C9            CAN2TAAK = REGBS+$1C9 ;CAN2 transmit message abort status
 01CA            CAN2TBEL = REGBS+$1CA ;CAN2 transmit buffer select
 01CB            CAN2IDAC = REGBS+$1CB ;CAN2 identfier acceptancecontrol
--- 0000           
 01CE            CAN2RERR = REGBS+$1CE ;CAN2 Receive error counter
 01CF            CAN2TERR = REGBS+$1CF ;CAN2 Transmit error counter
 01D0            CAN2IDA0 = REGBS+$1D0 ;CAN2 Identifier acceptanceregister 0
 01D1            CAN2IDA1 = REGBS+$1D1 ;CAN2 Identifier acceptanceregister 1
 01D2            CAN2IDA2 = REGBS+$1D2 ;CAN2 Identifier acceptanceregister 2
 01D3            CAN2IDA3 = REGBS+$1D3 ;CAN2 Identifier acceptanceregister 3
 01D4            CAN2IDM0 = REGBS+$1D4 ;CAN2 Identifier mask register 0
 01D5            CAN2IDM1 = REGBS+$1D5 ;CAN2 Identifier mask register 1
 01D6            CAN2IDM2 = REGBS+$1D6 ;CAN2 Identifier mask register 2
 01D7            CAN2IDM3 = REGBS+$1D7 ;CAN2 Identifier mask register 3
 01D8            CAN2IDA4 = REGBS+$1D8 ;CAN2 Identifier acceptanceregister 4
 01D9            CAN2IDA5 = REGBS+$1D9 ;CAN2 Identifier acceptanceregister 5
 01DA            CAN2IDA6 = REGBS+$1DA ;CAN2 Identifier acceptanceregister 6
 01DB            CAN2IDA7 = REGBS+$1DB ;CAN2 Identifier acceptanceregister 7
 01DC            CAN2IDM4 = REGBS+$1DC ;CAN2 Identifier mask register 4
 01DD            CAN2IDM5 = REGBS+$1DD ;CAN2 Identifier mask register 5
 01DE            CAN2IDM6 = REGBS+$1DE ;CAN2 Identifier mask register 6
 01DF            CAN2IDM7 = REGBS+$1DF ;CAN2 Identifier mask register 7
 01E0            CAN2RXFG = REGBS+$1E0 ;CAN2 RX foregroundbuffer thru +$1EF
 01F0            CAN2TXFG = REGBS+$1F0 ;CAN2 TX foregroundbuffer thru +$1FF
--- 0000           
 0200            CAN3CTL0 = REGBS+$200 ;CAN3 control register 0
 0201            CAN3CTL1 = REGBS+$201 ;CAN3 control register 1
 0202            CAN3BTR0 = REGBS+$202 ;CAN3 bus timing register 0
 0203            CAN3BTR1 = REGBS+$203 ;CAN3 bus timing register 1
 0204            CAN3RFLG = REGBS+$204 ;CAN3 receiver flags
 0205            CAN3RIER = REGBS+$205 ;CAN3 receiver interrupt enables
 0206            CAN3TFLG = REGBS+$206 ;CAN3 transmit flags
 0207            CAN3TIER = REGBS+$207 ;CAN3 transmit interrupt enables
 0208            CAN3TARQ = REGBS+$208 ;CAN3 transmit message abort control
 0209            CAN3TAAK = REGBS+$209 ;CAN3 transmit message abort status
 020A            CAN3TBEL = REGBS+$20A ;CAN3 transmit buffer select
 020B            CAN3IDAC = REGBS+$20B ;CAN3 identfier acceptancecontrol
--- 0000           
 020E            CAN3RERR = REGBS+$20E ;CAN3 Receive error counter
 020F            CAN3TERR = REGBS+$20F ;CAN3 Transmit error counter
 0210            CAN3IDA0 = REGBS+$210 ;CAN3 Identifier acceptanceregister 0
 0211            CAN3IDA1 = REGBS+$211 ;CAN3 Identifier acceptanceregister 1
 0212            CAN3IDA2 = REGBS+$212 ;CAN3 Identifier acceptanceregister 2
 0213            CAN3IDA3 = REGBS+$213 ;CAN3 Identifier acceptanceregister 3
 0214            CAN3IDM0 = REGBS+$214 ;CAN3 Identifier mask register 0
 0215            CAN3IDM1 = REGBS+$215 ;CAN3 Identifier mask register 1
 0216            CAN3IDM2 = REGBS+$216 ;CAN3 Identifier mask register 2
 0217            CAN3IDM3 = REGBS+$217 ;CAN3 Identifier mask register 3
 0218            CAN3IDA4 = REGBS+$218 ;CAN3 Identifier acceptanceregister 4
 0219            CAN3IDA5 = REGBS+$219 ;CAN3 Identifier acceptanceregister 5
 021A            CAN3IDA6 = REGBS+$21A ;CAN3 Identifier acceptanceregister 6
 021B            CAN3IDA7 = REGBS+$21B ;CAN3 Identifier acceptanceregister 7
 021C            CAN3IDM4 = REGBS+$21C ;CAN3 Identifier mask register 4
 021D            CAN3IDM5 = REGBS+$21D ;CAN3 Identifier mask register 5
 021E            CAN3IDM6 = REGBS+$21E ;CAN3 Identifier mask register 6
 021F            CAN3IDM7 = REGBS+$21F ;CAN3 Identifier mask register 7
 0220            CAN3RXFG = REGBS+$220 ;CAN3 RX foregroundbuffer thru +$22F
 0230            CAN3TXFG = REGBS+$230 ;CAN3 TX foregroundbuffer thru +$23F
--- 0000           
 0240            PTT = REGBS+$240 ;portT data register
 0241            PTIT = REGBS+$241 ;portT input register
 0242            DDRT = REGBS+$242 ;portT direction register
 0243            RDRT = REGBS+$243 ;portT reduced drive register
 0244            PERT = REGBS+$244 ;portT pull device enable
 0245            PPST = REGBS+$245 ;portT pull polarity select
--- 0000           
 0248            PTS = REGBS+$248 ;portS data register
 0249            PTIS = REGBS+$249 ;portS input register
 024A            DDRS = REGBS+$24A ;portS direction register
 024B            RDRS = REGBS+$24B ;portS reduced drive register
 024C            PERS = REGBS+$24C ;portS pull device enable
 024D            PPSS = REGBS+$24D ;portS pull polarity select
 024E            WOMS = REGBS+$24E ;portS Wired Or mode register
--- 0000           
 0250            PTM = REGBS+$250 ;portM data register
 0251            PTIM = REGBS+$251 ;portM input register
 0252            DDRM = REGBS+$252 ;portM direction register
 0253            RDRM = REGBS+$253 ;portM reduced drive register
 0254            PERM = REGBS+$254 ;portM pull device enable
 0255            PPSM = REGBS+$255 ;portM pull polarity select
 0256            WOMM = REGBS+$256 ;portM Wired Or mode register
 0257            MODRR = REGBS+$257 ;portM Module routing register
 0258            PTP = REGBS+$258 ;portP data register
 0259            PTIP = REGBS+$259 ;portP input register
 025A            DDRP = REGBS+$25A ;portP direction register
 025B            RDRP = REGBS+$25B ;portP reduced drive register
 025C            PERP = REGBS+$25C ;portP pull device enable
 025D            PPSP = REGBS+$25D ;portP pull polarity select
 025E            PIEP = REGBS+$25E ;portP interrupt enable register
 025F            PIFP = REGBS+$25F ;portP interrupt flag register
 0260            PTH = REGBS+$260 ;portH data register
 0261            PTIH = REGBS+$261 ;portH input register
 0262            DDRH = REGBS+$262 ;portH direction register
 0263            RDRH = REGBS+$263 ;portH reduced drive register
 0264            PERH = REGBS+$264 ;portH pull device enable
 0265            PPSH = REGBS+$265 ;portH pull polarity select
 0266            PIEH = REGBS+$266 ;portH interrupt enable register
 0267            PIFH = REGBS+$267 ;portH interrupt flag register
 0268            PTJ = REGBS+$268 ;portP data register
 0269            PTIJ = REGBS+$269 ;portP input register
 026A            DDRJ = REGBS+$26A ;portP direction register
 026B            RDRJ = REGBS+$26B ;portP reduced drive register
 026C            PERJ = REGBS+$26C ;portP pull device enable
 026D            PPSJ = REGBS+$26D ;portP pull polarity select
 026E            PIEJ = REGBS+$26E ;portP interrupt enable register
 026F            PIFJ = REGBS+$26F ;portP interrupt flag register
--- 0000           
 0280            CAN4CTL0 = REGBS+$280 ;CAN4 control register 0
 0281            CAN4CTL1 = REGBS+$281 ;CAN4 control register 1
 0282            CAN4BTR0 = REGBS+$282 ;CAN4 bus timing register 0
 0283            CAN4BTR1 = REGBS+$283 ;CAN4 bus timing register 1
 0284            CAN4RFLG = REGBS+$284 ;CAN4 receiver flags
 0285            CAN4RIER = REGBS+$285 ;CAN4 receiver interrupt enables
 0286            CAN4TFLG = REGBS+$286 ;CAN4 transmit flags
 0287            CAN4TIER = REGBS+$287 ;CAN4 transmit interrupt enables
 0288            CAN4TARQ = REGBS+$288 ;CAN4 transmit message abort control
 0289            CAN4TAAK = REGBS+$289 ;CAN4 transmit message abort status
 028A            CAN4TBEL = REGBS+$28A ;CAN4 transmit buffer select
 028B            CAN4IDAC = REGBS+$28B ;CAN4 identfier acceptancecontrol
--- 0000           
 028E            CAN4RERR = REGBS+$28E ;CAN4 Receive error counter
 028F            CAN4TERR = REGBS+$28F ;CAN4 Transmit error counter
 0290            CAN4IDA0 = REGBS+$290 ;CAN4 Identifier acceptanceregister 0
 0291            CAN4IDA1 = REGBS+$291 ;CAN4 Identifier acceptanceregister 1
 0292            CAN4IDA2 = REGBS+$292 ;CAN4 Identifier acceptanceregister 2
 0293            CAN4IDA3 = REGBS+$293 ;CAN4 Identifier acceptanceregister 3
 0294            CAN4IDM0 = REGBS+$294 ;CAN4 Identifier mask register 0
 0295            CAN4IDM1 = REGBS+$295 ;CAN4 Identifier mask register 1
 0296            CAN4IDM2 = REGBS+$296 ;CAN4 Identifier mask register 2
 0297            CAN4IDM3 = REGBS+$297 ;CAN4 Identifier mask register 3
 0298            CAN4IDA4 = REGBS+$298 ;CAN4 Identifier acceptanceregister 4
 0299            CAN4IDA5 = REGBS+$299 ;CAN4 Identifier acceptanceregister 5
 029A            CAN4IDA6 = REGBS+$29A ;CAN4 Identifier acceptanceregister 6
 029B            CAN4IDA7 = REGBS+$29B ;CAN4 Identifier acceptanceregister 7
 029C            CAN4IDM4 = REGBS+$29C ;CAN4 Identifier mask register 4
 029D            CAN4IDM5 = REGBS+$29D ;CAN4 Identifier mask register 5
 029E            CAN4IDM6 = REGBS+$29E ;CAN4 Identifier mask register 6
 029F            CAN4IDM7 = REGBS+$29F ;CAN4 Identifier mask register 7
 02A0            CAN4RXFG = REGBS+$2A0 ;CAN4 RX foregroundbuffer thru +$2AF
 02B0            CAN4TXFG = REGBS+$2B0 ;CAN4 TX foregroundbuffer thru +$2BF
--- 0000           
--- 0000           ; ========================================================
--- 0000           ;	basicLCD	Include file with minimal support 
--- 0000           ;			for LCD
--- 0000           ;	Requires : dp256reg.asm
--- 0000           ;
--- 0000           ;	Hacked from Lcd_2PP.asm:     L  Parallel Lcd Driver 
--- 0000           ;         Version:       1.0   Released 11/01/2002
--- 0000           ;          Author:       Gary Karnes , Axiom Manufacturing
--- 0000           ;        Compiler:       Asm12
--- 0000           ;        Platform:       CML12S & PROJECT BOARD 
--- 0000           ;
--- 0000           ; ========================================================
--- 0000           ;
--- 0000           ; Equates
 0001           U21_N = $01           ; LCD unused pin
 0002           LCD_RW = $02          ; LCD RW select (PT1)
 0004           LCD_RS = $04          ; LCD RS select	(PT2)
 0008           LCD_EN = $08          ; LCD EN select	(PT3)
 0080           U21_EN = $80
--- 0000           
 402A            _LCD_instruction::
 402A  3B                 pshd
 402B  34                 pshx
 402C  35                 pshy
 402D  180F               tba
 402F  1640A4             jsr LD2PP_Instruction
 4032  31                 puly
 4033  30                 pulx
 4034  3A                 puld
 4035  3D                 rts
 4036            _LCD_display::
 4036  3B                 pshd
 4037  34                 pshx
 4038  35                 pshy
 4039  180F               tba
 403B  16409C             jsr LCD2PP_Data
 403E  31                 puly
 403F  30                 pulx
 4040  3A                 puld
 4041  3D                 rts
 4042                     
 4042            ;-----------
 4042            _Lcd2PP_Init::
 4042  3B                 pshd
 4043  34                 pshx
 4044  35                 pshy
 4045  16404C             jsr Lcd2PP_Init
 4048  31                 puly
 4049  30                 pulx
 404A  3A                 puld
 404B  3D                 rts    
 404C                      
 404C            Lcd2PP_Init:	; Note : Use 4-bit init sequence (not 8-bit)  Page 3 LCD_spec.pdf
 404C            		; Bottom table contains sequence of instructions
 404C            		; Each row in the table represents one WRITE to the LCD instruction register (via Port P)
 404C            		;	First instruction involves only a 4-bit instruction (one WRITE)
 404C            		;	Following instructions involve 8 bit instruction, therefore
 404C            		;		2 * 4-bit writes
 404C            
 404C            	; "System init"
 404C            	; Setup Port T for output
 404C  180B0F0242           movb #$0F,DDRT        ; setup port T
 4051  180B000240           movb #$00,PTT         ; all low
 4056                    ; Disable SPI AND setup SPI1 as four output bits
 4056  1C025A0F                bset  DDRP,#$0F           ; set P0-3 as outputs
 405A  1D00F040            bclr  SPI1CR1,#$40    ; Disable SP by turning SPI1 off
 405E            
 405E  180BFE0252           movb #$FE,DDRM        ; set PM1-7 as outputs
 4063  180B000250           movb #$00,PTM         ; D.P.(PM2) = Off, U7_EN(PM3)= low,
 4068                                            ; SS0*(PM4), SS1*(PM5), SS2*(PM6) = Low
 4068                                            ; Heat(PM7) = Off
 4068            
 4068  1D02400E            bclr    PTT,LCD_RW+LCD_RS+LCD_EN  ; select lcd commands Cs=0 En=0
 406C            
 406C  1640EA              jsr      DELAY50M
 406F  8602                ldaa     #$02         ; Set to 4-bit operation (0010)
 4071  1640B0              jsr      LCD2PP_4     ; This first instruction is only 4 bits long!!!  Rest are 8 bits.  
 4074  1640EA              jsr      DELAY50M
 4077            
 4077                    ;  ldaa     #$2c                ; Function Set = 001(D/L)NF** where D/L = 0(4-bit) N=1(2-lines) F=0(font=5x7 dots)
 4077  8628                ldaa     #$28         ; Function Set = 001(D/L)NF** where D/L = 0(4-bit) N=1(2-lines) F=0(font=5x7 dots)
 4079  1640A4              jsr      LD2PP_Instruction         
 407C  1640F8              jsr      DELAY10M         
 407F            
 407F  860E                ldaa      #$0e        ; Display On/off Control = 00001DCB where D=1(display on) C=1(cursor on) B=0 (blink off)
 4081  1640A4              jsr      LD2PP_Instruction          
 4084  1640F8              jsr      DELAY10M          
 4087                            
 4087  8601                ldaa     #$01         ; Clear display = 00000001
 4089  1640A4              jsr      LD2PP_Instruction           
 408C  1640F3              jsr      DELAY20M          
 408F  8680                ldaa     #$80         ; DDRAM Address Set = 01xxxxxx where xxxxxx = address
 4091  1640A4              jsr      LD2PP_Instruction
 4094  1640F8              jsr      DELAY10M        
 4097            
 4097            ; Reset Lcd states to rest
 4097  1D02400E           bclr    PTT,LCD_RS+LCD_RW+LCD_EN ; turn all signals off on lcd
 409B  3D                  rts
 409C            ;
 409C            ;-----------------------------------------------
 409C            ; Lcd Routines
 409C            ;
 409C            ; Write a byte to the LCD Data Register
 409C            LCD2PP_Data:
 409C  1C024004        bset  PTT,LCD_RS     ; select lcd data buffer RS=1
 40A0  1640DD          jsr   LCD_W_8        ; write byte
 40A3  3D              rts
 40A4            
 40A4            ; Write a byte to the LCD Instruction Register (leaves LCD in Data mode)
 40A4            LD2PP_Instruction:
 40A4  1D024004          bclr   PTT,LCD_RS        ; select lcd command buffer
 40A8  1640DD            jsr    LCD_W_8           ; wait
 40AB  1C024004          bset   PTT,LCD_RS        ; select data buffer
 40AF  3D                rts
 40B0            
 40B0            LCD2PP_4:			; Destroys a and b
 40B0  1C024880           bset   PTS,#U21_EN     ; set U21_EN high so that latch becomes transparent
 40B4  164101             jsr      DELAY1MS      ; delay     
 40B7  F60258             ldab     PTP              ; Port P
 40BA  C4F0               andb     #$f0             ; get only bits 4 - 7
 40BC  840F               anda     #$0f             ; get data
 40BE  1806               aba
 40C0  7A0258             staa     PTP              ; save data 
 40C3                    //For ;LCD's write cycle, Enable must pulse high and then low (for specified time)
 40C3  1D024008           bclr     PTT,LCD_EN       ; enable low
 40C7  164101             jsr      DELAY1MS         ; delay for LCD
 40CA  1C024008           bset     PTT,LCD_EN       ; latch data
 40CE  164101             jsr      DELAY1MS         ; delay for LCD 
 40D1  1D024008           bclr     PTT,LCD_EN           ; enable low
 40D5  164101             jsr      DELAY1MS
 40D8  1D024880           bclr  PTS,#U21_EN    ; set U21_EN low to isolate LCD from parallel control (outputs are latched)
 40DC  3D                 rts
 40DD            ;
 40DD            ;
 40DD            ; Lcd Write 8 bit Data , lower 4 bits first in acc A   (Destroys A)
 40DD            LCD_W_8:					
 40DD  36                 psha                     ; save a 
 40DE  44                 lsra                     ; shift upper 4 bits to lower
 40DF  44                 lsra
 40E0  44                 lsra
 40E1  44                 lsra
 40E2  1640B0             jsr      LCD2PP_4        ; write upper 4 bits to lcd
 40E5  32                 pula
 40E6  1640B0             jsr      LCD2PP_4         ; write lower 4 bits to lcd
 40E9  3D                 rts
 40EA                                                    
 40EA            
 40EA            ;
 40EA            ; Delay routines
 40EA            ;
 40EA            ;
 40EA            ; Generate a 50 ms delay
 40EA            DELAY50M:
 40EA  34                  pshx
 40EB  CEC34E              ldx  #49998      ; delay 50,000 usecs,
 40EE  16410A              jsr  DELML01     ; call usec delay
 40F1  30                  pulx
 40F2  3D                  rts
 40F3            ;
 40F3            ;
 40F3            ; Generate a 20 ms delay
 40F3            DELAY20M:
 40F3  0703                bsr  DELAY10M
 40F5  0701                bsr  DELAY10M 
 40F7  3D                  rts
 40F8            ;
 40F8            ; Generate a 10 ms delay
 40F8            DELAY10M:                            ; jsr=4cyles
 40F8  34                  pshx             ; 2 cycles ,save x
 40F9  CE270E              ldx  #9998       ; 2 cycles,delay 9998 usec + 2 for this routine
 40FC  16410A              jsr  DELML01     ; call usec delay, this delay offset in sub
 40FF  30                  pulx             ; 3 cycles restore x
 4100  3D                  rts              ; 5 cycles
 4101            ;
 4101            ;
 4101            ; Generate a 1 ms delay
 4101            DELAY1MS:
 4101                                       ; jsr=4cyles
 4101  34                  pshx             ; 2 cycles ,save x
 4102  CE03E6              ldx  #998       ; 2 cycles,delay 9998 usec + 2 for this routine
 4105  16410A              jsr  DELML01     ; call usec delay, this delay offset in sub
 4108  30                  pulx             ; 3 cycles restore x
 4109  3D                  rts              ; 5 cycles
 410A            
 410A            
 410A            ;
 410A            ; 8 cycles = 1 usec e = 8mhz
 410A            DELML01:
 410A  A7                  nop              ; 1 cycle
 410B  A7                  nop              ; 1 cycle
 410C  A7                  nop              ; 1 cycle
 410D  A7                  nop              ; 1 cycle
 410E  09                  dex              ; 1 cycle 
 410F  26F9                bne   DELML01    ; 3 cycles
 4111  3D                  rts              ; 5 cycles
 4112            
                        .area text
--- 00E8                   .dbfile Assign42.C
--- 00E8                   .dbfunc e main _main fV
 4112            _main::
 4112  34                pshx
 4113  B775              tfr s,x
 4115  1B9E              leas -2,sp
 4117                    .dbline -1
 4117                    .dbline 12
 4117            ; /*
 4117            ; Authors Fady Ibrahim 100876906, Gavez Smith 100857991 
 4117            ; */
 4117            ; 
 4117            ; #include"stdio.h"
 4117            ; #include <hcs12dp256.h>
 4117            ; asm(".include'basicLCD.s'");
 4117            ; 
 4117            ; void Inc_Dec_Speed(int speed, int temp );
 4117            ; void displaySpeed_Temp(int speed, int temp);
 4117            ; 
 4117            ; void main(){
 4117                    .dbline 13
 4117            ;        Lcd2PP_Init();
 4117  164042            jsr _Lcd2PP_Init
 411A                    .dbline 14
 411A            ;      Inc_Dec_Speed(123,32);
 411A  CC0020            ldd #32
 411D  6C80              std 0,sp
 411F  CC007B            ldd #123
 4122  1642BC            jsr _Inc_Dec_Speed
 4125                    .dbline -2
 4125                    .dbline 15
 4125            ; }
 4125            L3:
 4125  B757              tfr x,s
 4127  30                pulx
 4128                    .dbline 0 ; func end
 4128  3D                rts
 4129                    .dbend
 4129                    .dbfunc e displaySpeed_Temp _displaySpeed_Temp fV
 4129            ; arraycharstemp -> -22,x
 4129            ;     arraychars -> -18,x
 4129            ;    holderSpeed -> -10,x
 4129            ;     holderTemp -> -8,x
 4129            ;         number -> -6,x
 4129            ;      remainder -> -4,x
 4129            ;          index -> -2,x
 4129            ;           temp -> 6,x
 4129            ;          speed -> 2,x
 4129            _displaySpeed_Temp::
 4129  3B                pshd
 412A  34                pshx
 412B  B775              tfr s,x
 412D  1BF1E8            leas -24,sp
 4130                    .dbline -1
 4130                    .dbline 20
 4130            ; /*
 4130            ; DisplaySpeed_Temp displays the speed and temp passed in to the lcd display.
 4130            ; */
 4130            ; 
 4130            ; void displaySpeed_Temp(int speed, int temp){  
 4130                    .dbline 22
 4130            ;        int number;
 4130            ;        int index=3;
 4130  CC0003            ldd #3
 4133  6C1E              std -2,x
 4135                    .dbline 25
 4135            ;        int arraychars[4];
 4135            ;        int arraycharstemp[2];
 4135            ;        int remainder=0;
 4135  CC0000            ldd #0
 4138  6C1C              std -4,x
 413A                    .dbline 26
 413A            ;        int holderSpeed=speed;
 413A  ED02              ldy 2,x
 413C  6D16              sty -10,x
 413E                    .dbline 27
 413E            ;        int holderTemp=temp;
 413E  18020618          movw 6,x,-8,x
 4142                    .dbline 28
 4142            ;      LCD_instruction();
 4142  16402A            jsr _LCD_instruction
 4145                    .dbline 29
 4145            ;        LCD_display('S');
 4145  CC0053            ldd #83
 4148  164036            jsr _LCD_display
 414B                    .dbline 30
 414B            ;        LCD_display('P');
 414B  CC0050            ldd #80
 414E  164036            jsr _LCD_display
 4151                    .dbline 31
 4151            ;        LCD_display('E');
 4151  CC0045            ldd #69
 4154  164036            jsr _LCD_display
 4157                    .dbline 32
 4157            ;        LCD_display('E');
 4157  CC0045            ldd #69
 415A  164036            jsr _LCD_display
 415D                    .dbline 33
 415D            ;        LCD_display('D');
 415D  CC0044            ldd #68
 4160  164036            jsr _LCD_display
 4163  205A              bra L6
 4165            L5:
 4165                    .dbline 35
 4165            ;        while (index>=0)
 4165            ;        {
 4165                    .dbline 36
 4165            ;        if(holderSpeed!=0)
 4165  EC16              ldd -10,x
 4167  273C              beq L8
 4169                    .dbline 37
 4169            ;        {
 4169                    .dbline 39
 4169            ; //takes the decimal value passed in and turns it into the decimal value representation in ASCII
 4169            ;        remainder=holderSpeed%10;
 4169  EC16              ldd -10,x
 416B  CD000A            ldy #10
 416E  B7D6              exg x,y
 4170  1815              idivs
 4172  B7D6              exg x,y
 4174  6C1C              std -4,x
 4176                    .dbline 40
 4176            ;        holderSpeed=holderSpeed/10;
 4176  EC16              ldd -10,x
 4178  CD000A            ldy #10
 417B  B7D6              exg x,y
 417D  1815              idivs
 417F  B7D6              exg x,y
 4181  6D16              sty -10,x
 4183                    .dbline 41
 4183            ;        remainder=remainder+0x30;
 4183  EC1C              ldd -4,x
 4185  C30030            addd #48
 4188  6C1C              std -4,x
 418A                    .dbline 42
 418A            ;        arraychars[index]=remainder;
 418A  19E1EE            leay -18,x
 418D  6DE1E8            sty -24,x
 4190  EC1E              ldd -2,x
 4192  59                lsld
 4193  E3E1E8            addd -24,x
 4196  B7C6              xgdy
 4198  EC1C              ldd -4,x
 419A  6C40              std 0,y
 419C                    .dbline 43
 419C            ;        index=index-1;
 419C  EC1E              ldd -2,x
 419E  830001            subd #1
 41A1  6C1E              std -2,x
 41A3                    .dbline 44
 41A3            ;        }       
 41A3  201A              bra L9
 41A5            L8:
 41A5                    .dbline 46
 41A5            ;        else
 41A5            ;        {
 41A5                    .dbline 47
 41A5            ;         arraychars[index]=0x30;
 41A5  19E1EE            leay -18,x
 41A8  6DE1E8            sty -24,x
 41AB  EC1E              ldd -2,x
 41AD  59                lsld
 41AE  E3E1E8            addd -24,x
 41B1  B7C6              xgdy
 41B3  CC0030            ldd #48
 41B6  6C40              std 0,y
 41B8                    .dbline 48
 41B8            ;         index=index-1;
 41B8  EC1E              ldd -2,x
 41BA  830001            subd #1
 41BD  6C1E              std -2,x
 41BF                    .dbline 49
 41BF            ;        }
 41BF            L9:
 41BF                    .dbline 50
 41BF            L6:
 41BF                    .dbline 34
 41BF  EC1E              ldd -2,x
 41C1  2CA2              bge L5
 41C3                    .dbline 51
 41C3            ;        }
 41C3            ;        LCD_display(' ');
 41C3  CC0020            ldd #32
 41C6  164036            jsr _LCD_display
 41C9                    .dbline 52
 41C9            ;        for(index=0;index<4;index++)
 41C9  CC0000            ldd #0
 41CC  6C1E              std -2,x
 41CE            L10:
 41CE                    .dbline 53
 41CE                    .dbline 54
 41CE  19E1EE            leay -18,x
 41D1  6DE1E8            sty -24,x
 41D4  EC1E              ldd -2,x
 41D6  59                lsld
 41D7  E3E1E8            addd -24,x
 41DA  B7C6              xgdy
 41DC  ED40              ldy 0,y
 41DE  6D1A              sty -6,x
 41E0                    .dbline 56
 41E0  EC1A              ldd -6,x
 41E2  164036            jsr _LCD_display
 41E5                    .dbline 57
 41E5            L11:
 41E5                    .dbline 52
 41E5  EC1E              ldd -2,x
 41E7  C30001            addd #1
 41EA  6C1E              std -2,x
 41EC                    .dbline 52
 41EC  EC1E              ldd -2,x
 41EE  8C0004            cpd #4
 41F1  2DDB              blt L10
 41F3                    .dbline 59
 41F3            ;        {
 41F3            ;               number=arraychars[index];
 41F3            ; 
 41F3            ;                LCD_display(number);
 41F3            ;        }
 41F3            ;        
 41F3            ;        index=1;
 41F3  CC0001            ldd #1
 41F6  6C1E              std -2,x
 41F8                    .dbline 61
 41F8            ;        //goes to the next line.
 41F8            ;        LCD_instruction(0xC0); 
 41F8  CC00C0            ldd #192
 41FB  16402A            jsr _LCD_instruction
 41FE                    .dbline 62
 41FE            ;        LCD_display('T');
 41FE  CC0054            ldd #84
 4201  164036            jsr _LCD_display
 4204                    .dbline 63
 4204            ;        LCD_display('E');
 4204  CC0045            ldd #69
 4207  164036            jsr _LCD_display
 420A                    .dbline 64
 420A            ;        LCD_display('M');
 420A  CC004D            ldd #77
 420D  164036            jsr _LCD_display
 4210                    .dbline 65
 4210            ;        LCD_display('P');
 4210  CC0050            ldd #80
 4213  164036            jsr _LCD_display
 4216                    .dbline 66
 4216            ;        LCD_display('E');
 4216  CC0045            ldd #69
 4219  164036            jsr _LCD_display
 421C                    .dbline 67
 421C            ;        LCD_display('R');
 421C  CC0052            ldd #82
 421F  164036            jsr _LCD_display
 4222                    .dbline 68
 4222            ;        LCD_display('A');
 4222  CC0041            ldd #65
 4225  164036            jsr _LCD_display
 4228                    .dbline 69
 4228            ;        LCD_display('T');
 4228  CC0054            ldd #84
 422B  164036            jsr _LCD_display
 422E                    .dbline 70
 422E            ;        LCD_display('U');
 422E  CC0055            ldd #85
 4231  164036            jsr _LCD_display
 4234                    .dbline 71
 4234            ;        LCD_display('R');
 4234  CC0052            ldd #82
 4237  164036            jsr _LCD_display
 423A                    .dbline 72
 423A            ;        LCD_display('E');
 423A  CC0045            ldd #69
 423D  164036            jsr _LCD_display
 4240  203A              bra L15
 4242            L14:
 4242                    .dbline 75
 4242                    .dbline 76
 4242  EC18              ldd -8,x
 4244  CD000A            ldy #10
 4247  B7D6              exg x,y
 4249  1815              idivs
 424B  B7D6              exg x,y
 424D  6C1C              std -4,x
 424F                    .dbline 77
 424F  EC18              ldd -8,x
 4251  CD000A            ldy #10
 4254  B7D6              exg x,y
 4256  1815              idivs
 4258  B7D6              exg x,y
 425A  6D18              sty -8,x
 425C                    .dbline 78
 425C  EC1C              ldd -4,x
 425E  C30030            addd #48
 4261  6C1C              std -4,x
 4263                    .dbline 79
 4263  19E1EA            leay -22,x
 4266  6DE1E8            sty -24,x
 4269  EC1E              ldd -2,x
 426B  59                lsld
 426C  E3E1E8            addd -24,x
 426F  B7C6              xgdy
 4271  EC1C              ldd -4,x
 4273  6C40              std 0,y
 4275                    .dbline 80
 4275  EC1E              ldd -2,x
 4277  830001            subd #1
 427A  6C1E              std -2,x
 427C                    .dbline 81
 427C            L15:
 427C                    .dbline 74
 427C            ; 
 427C            ;        while (index>=0)
 427C  EC1E              ldd -2,x
 427E  2CC2              bge L14
 4280                    .dbline 82
 4280            ;        {
 4280            ;        remainder=holderTemp%10;
 4280            ;      holderTemp=holderTemp/10;
 4280            ;        remainder=remainder+0x30;
 4280            ;        arraycharstemp[index]=remainder;
 4280            ;        index=index-1;
 4280            ;        } 
 4280            ;        LCD_display(' ');
 4280  CC0020            ldd #32
 4283  164036            jsr _LCD_display
 4286                    .dbline 83
 4286            ;                for(index=0;index<2;index++)
 4286  CC0000            ldd #0
 4289  6C1E              std -2,x
 428B            L17:
 428B                    .dbline 84
 428B                    .dbline 85
 428B  19E1EA            leay -22,x
 428E  6DE1E8            sty -24,x
 4291  EC1E              ldd -2,x
 4293  59                lsld
 4294  E3E1E8            addd -24,x
 4297  B7C6              xgdy
 4299  ED40              ldy 0,y
 429B  6D1A              sty -6,x
 429D                    .dbline 87
 429D  EC1A              ldd -6,x
 429F  164036            jsr _LCD_display
 42A2                    .dbline 88
 42A2            L18:
 42A2                    .dbline 83
 42A2  EC1E              ldd -2,x
 42A4  C30001            addd #1
 42A7  6C1E              std -2,x
 42A9                    .dbline 83
 42A9  EC1E              ldd -2,x
 42AB  8C0002            cpd #2
 42AE  2DDB              blt L17
 42B0                    .dbline 90
 42B0            ;        {
 42B0            ;               number=arraycharstemp[index];
 42B0            ; 
 42B0            ;                LCD_display(number);
 42B0            ;        }
 42B0            ;        
 42B0            ;        LCD_display('C');
 42B0  CC0043            ldd #67
 42B3  164036            jsr _LCD_display
 42B6                    .dbline -2
 42B6                    .dbline 91
 42B6            ; }
 42B6            L4:
 42B6  B757              tfr x,s
 42B8  30                pulx
 42B9  1B82              leas 2,sp
 42BB                    .dbline 0 ; func end
 42BB  3D                rts
 42BC                    .dbsym l arraycharstemp -22 A[4:2]I
 42BC                    .dbsym l arraychars -18 A[8:4]I
 42BC                    .dbsym l holderSpeed -10 I
 42BC                    .dbsym l holderTemp -8 I
 42BC                    .dbsym l number -6 I
 42BC                    .dbsym l remainder -4 I
 42BC                    .dbsym l index -2 I
 42BC                    .dbsym l temp 6 I
 42BC                    .dbsym l speed 2 I
 42BC                    .dbend
 42BC                    .dbfunc e Inc_Dec_Speed _Inc_Dec_Speed fV
 42BC            ;           loop -> -9,x
 42BC            ;    speedholder -> -7,x
 42BC            ;     keypressed -> -5,x
 42BC            ;        counter -> -4,x
 42BC            ;              i -> -2,x
 42BC            ;           temp -> 6,x
 42BC            ;          speed -> 2,x
 42BC            _Inc_Dec_Speed::
 42BC  3B                pshd
 42BD  34                pshx
 42BE  B775              tfr s,x
 42C0  1B94              leas -12,sp
 42C2                    .dbline -1
 42C2                    .dbline 99
 42C2            ; /*
 42C2            ; 
 42C2            ; Inc_Dec_speed checks to see if e or d was pressed if it was it will decrease the speed by 1 or increase the speed by 1
 42C2            ; then it will pass the values into displaySpeed_temp and display it on the LCD board.
 42C2            ; */
 42C2            ; 
 42C2            ; 
 42C2            ; void Inc_Dec_Speed(int speed, int temp ){
 42C2                    .dbline 100
 42C2            ;       int speedholder=speed;
 42C2  18020219          movw 2,x,-7,x
 42C6                    .dbline 101
 42C6            ;       int i=0;
 42C6  CC0000            ldd #0
 42C9  6C1E              std -2,x
 42CB                    .dbline 102
 42CB            ;       int loop=0;
 42CB  CC0000            ldd #0
 42CE  6C17              std -9,x
 42D0                    .dbline 103
 42D0            ;       char keypressed=0;
 42D0  691B              clr -5,x
 42D2                    .dbline 104
 42D2            ;       int counter=1;
 42D2  CC0001            ldd #1
 42D5  6C1C              std -4,x
 42D7                    .dbline 105
 42D7            ;       SPI1CR1=0x00;
 42D7  7900F0            clr 0xf0
 42DA                    .dbline 106
 42DA            ;       DDRP=0x0F;
 42DA  C60F              ldab #15
 42DC  7B025A            stab 0x25a
 42DF                    .dbline 107
 42DF            ;       DDRH=0x00;
 42DF  790262            clr 0x262
 42E2                    .dbline 108
 42E2            ;       displaySpeed_Temp(speedholder, temp);
 42E2  18020680          movw 6,x,0,sp
 42E6  EC19              ldd -7,x
 42E8  164129            jsr _displaySpeed_Temp
 42EB  182000B9          lbra L23
 42EF            L22:
 42EF                    .dbline 110
 42EF            ;       while (loop==0)
 42EF            ;       {
 42EF                    .dbline 111
 42EF            ;       PTM = 0x08;                                                             
 42EF  C608              ldab #8
 42F1  7B0250            stab 0x250
 42F4                    .dbline 112
 42F4            ;       PTP=counter;
 42F4  EC1C              ldd -4,x
 42F6  7B0258            stab 0x258
 42F9                    .dbline 113
 42F9            ;       keypressed=PTH;
 42F9                    ; vol
 42F9  F60260            ldab 0x260
 42FC  6B1B              stab -5,x
 42FE                    .dbline 114
 42FE            ;       PTM &= 0x00;
 42FE  CC0000            ldd #0
 4301  7B0250            stab 0x250
 4304                    .dbline 115
 4304            ;       keypressed &= 0xF0;
 4304  0D1B0F            bclr -5,x,#0xf
 4307                    .dbline 117
 4307            ; 
 4307            ;       printf("PTH= %x\n", PTH);
 4307                    ; vol
 4307  F60260            ldab 0x260
 430A  87                clra
 430B  6C80              std 0,sp
 430D  CC43D1            ldd #L25
 4310  16482A            jsr _printf
 4313                    .dbline 118
 4313            ; printf("Keypressed= %x\n", keypressed);
 4313  E61B              ldab -5,x
 4315  87                clra
 4316  6C80              std 0,sp
 4318  CC43C1            ldd #L26
 431B  16482A            jsr _printf
 431E                    .dbline 119
 431E            ; printf("Counter= %x\n", counter);                                     
 431E  18021C80          movw -4,x,0,sp
 4322  CC43B4            ldd #L27
 4325  16482A            jsr _printf
 4328                    .dbline 120
 4328            ;        if (keypressed==0x10 && counter==1)
 4328  E61B              ldab -5,x
 432A  C110              cmpb #16
 432C  2619              bne L28
 432E  EC1C              ldd -4,x
 4330  8C0001            cpd #1
 4333  2612              bne L28
 4335                    .dbline 121
 4335            ;       {
 4335                    .dbline 122
 4335            ;               speedholder+=1;
 4335  EC19              ldd -7,x
 4337  C30001            addd #1
 433A  6C19              std -7,x
 433C                    .dbline 123
 433C            ;           displaySpeed_Temp(speedholder, temp);
 433C  18020680          movw 6,x,0,sp
 4340  EC19              ldd -7,x
 4342  164129            jsr _displaySpeed_Temp
 4345                    .dbline 125
 4345            ;          
 4345            ;        }
 4345  201D              bra L29
 4347            L28:
 4347                    .dbline 126
 4347            ;       else if (keypressed==0x80 && counter==1)
 4347  E61B              ldab -5,x
 4349  C180              cmpb #128
 434B  2617              bne L30
 434D  EC1C              ldd -4,x
 434F  8C0001            cpd #1
 4352  2610              bne L30
 4354                    .dbline 127
 4354            ;       {
 4354                    .dbline 128
 4354            ;           speedholder-=1;
 4354  EC19              ldd -7,x
 4356  830001            subd #1
 4359  6C19              std -7,x
 435B                    .dbline 129
 435B            ;           displaySpeed_Temp(speedholder,  temp);
 435B  18020680          movw 6,x,0,sp
 435F  EC19              ldd -7,x
 4361  164129            jsr _displaySpeed_Temp
 4364                    .dbline 130
 4364            ;       }
 4364            L30:
 4364            L29:
 4364                    .dbline 131
 4364  CC0000            ldd #0
 4367  6C1E              std -2,x
 4369            L32:
 4369                    .dbline 131
 4369            L33:
 4369                    .dbline 131
 4369            ;       for ( i=0;i<10000;i++);
 4369  EC1E              ldd -2,x
 436B  C30001            addd #1
 436E  6C1E              std -2,x
 4370                    .dbline 131
 4370  EC1E              ldd -2,x
 4372  8C2710            cpd #10000
 4375  2DF2              blt L32
 4377                    .dbline 133
 4377            ;       
 4377            ;       if(counter>=2)
 4377  EC1C              ldd -4,x
 4379  8C0002            cpd #2
 437C  2D09              blt L36
 437E                    .dbline 134
 437E            ;       {
 437E                    .dbline 135
 437E            ;       counter=counter +2;
 437E  EC1C              ldd -4,x
 4380  C30002            addd #2
 4383  6C1C              std -4,x
 4385                    .dbline 136
 4385            ;       }
 4385  2007              bra L37
 4387            L36:
 4387                    .dbline 138
 4387            ;       else
 4387            ;       {
 4387                    .dbline 139
 4387            ;       counter++;
 4387  EC1C              ldd -4,x
 4389  C30001            addd #1
 438C  6C1C              std -4,x
 438E                    .dbline 140
 438E            ;       }
 438E            L37:
 438E                    .dbline 141
 438E            ;       if (counter==6)
 438E  EC1C              ldd -4,x
 4390  8C0006            cpd #6
 4393  2607              bne L38
 4395                    .dbline 142
 4395            ;       {
 4395                    .dbline 143
 4395            ;       counter=counter+2;
 4395  EC1C              ldd -4,x
 4397  C30002            addd #2
 439A  6C1C              std -4,x
 439C                    .dbline 144
 439C            ;       }
 439C            L38:
 439C                    .dbline 145
 439C            ;       if (counter>8)
 439C  EC1C              ldd -4,x
 439E  8C0008            cpd #8
 43A1  2F05              ble L40
 43A3                    .dbline 146
 43A3            ;       {
 43A3                    .dbline 147
 43A3            ;       counter=1;
 43A3  CC0001            ldd #1
 43A6  6C1C              std -4,x
 43A8                    .dbline 148
 43A8            ;       }
 43A8            L40:
 43A8                    .dbline 149
 43A8            L23:
 43A8                    .dbline 109
 43A8  EC17              ldd -9,x
 43AA  1827FF41          lbeq L22
 43AE                    .dbline -2
 43AE                    .dbline 150
 43AE            ;       }
 43AE            ; }
 43AE            L21:
 43AE  B757              tfr x,s
 43B0  30                pulx
 43B1  1B82              leas 2,sp
 43B3                    .dbline 0 ; func end
 43B3  3D                rts
 43B4                    .dbsym l loop -9 I
 43B4                    .dbsym l speedholder -7 I
 43B4                    .dbsym l keypressed -5 c
 43B4                    .dbsym l counter -4 I
 43B4                    .dbsym l i -2 I
 43B4                    .dbsym l temp 6 I
 43B4                    .dbsym l speed 2 I
 43B4                    .dbend
 43B4            L27:
 43B4  436F756E7465723D2025780A00        .byte 'C,'o,'u,'n,'t,'e,'r,61,32,37,'x,10,0
 43C1            L26:
 43C1  4B6579707265737365643D2025780A00  .byte 'K,'e,'y,'p,'r,'e,'s,'s,'e,'d,61,32,37,'x,10,0
 43D1            L25:
 43D1  5054483D2025780A00        .byte 'P,'T,'H,61,32,37,'x,10,0
