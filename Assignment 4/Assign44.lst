WARNING: EXTCODE CODE AREA DO NOT CONTAIN RELOCATED ADDRESSES.
THIS WILL BE REMEDIED IN A LATER RELEASE.
                        .module Assign44.C
                        .area memory(abs)
                        .org 0x3f8c
 3F8C            _interrupt_vectors::
 3F8C  F8CF              .word 63695
 3F8E  F8CF              .word 63695
 3F90  F8CF              .word 63695
 3F92  F8CF              .word 63695
 3F94  F8CF              .word 63695
 3F96  F8CF              .word 63695
 3F98  F8CF              .word 63695
 3F9A  F8CF              .word 63695
 3F9C  F8CF              .word 63695
 3F9E  F8CF              .word 63695
 3FA0  F8CF              .word 63695
 3FA2  F8CF              .word 63695
 3FA4  F8CF              .word 63695
 3FA6  F8CF              .word 63695
 3FA8  F8CF              .word 63695
 3FAA  F8CF              .word 63695
 3FAC  F8CF              .word 63695
 3FAE  F8CF              .word 63695
 3FB0  F8CF              .word 63695
 3FB2  F8CF              .word 63695
 3FB4  F8CF              .word 63695
 3FB6  F8CF              .word 63695
 3FB8  F8CF              .word 63695
 3FBA  F8CF              .word 63695
 3FBC  F8CF              .word 63695
 3FBE  F8CF              .word 63695
 3FC0  F8CF              .word 63695
 3FC2  F8CF              .word 63695
 3FC4  F8CF              .word 63695
 3FC6  F8CF              .word 63695
 3FC8  F8CF              .word 63695
 3FCA  F8CF              .word 63695
 3FCC  4135              .word _keyboardISR
 3FCE  F8CF              .word 63695
 3FD0  F8CF              .word 63695
 3FD2  F8CF              .word 63695
 3FD4  F8CF              .word 63695
 3FD6  F8CF              .word 63695
 3FD8  F8CF              .word 63695
 3FDA  F8CF              .word 63695
 3FDC  F8CF              .word 63695
 3FDE  F8CF              .word 63695
 3FE0  F8CF              .word 63695
 3FE2  F8CF              .word 63695
 3FE4  F8CF              .word 63695
 3FE6  F8CF              .word 63695
 3FE8  F8CF              .word 63695
 3FEA  F8CF              .word 63695
 3FEC  F8CF              .word 63695
 3FEE  F8CF              .word 63695
 3FF0  4090              .word _CollisionDetect
 3FF2  F8CF              .word 63695
 3FF4  F8C7              .word 63687
 3FF6  F8C3              .word 63683
 3FF8  F8CB              .word 63691
 3FFA  F805              .word 63493
 3FFC  F809              .word 63497
 3FFE  4000              .word __start
 4000                    .dbfile M:\Sysc 2003\Assignment 4/vectors_dp256_NoICE1.c
 4000                    .dbsym e interrupt_vectors _interrupt_vectors A[116:58]pfV
                        .area data
--- 0000                   .dbfile M:\Sysc 2003\Assignment 4/vectors_dp256_NoICE1.c
 1000            _x::
 1000                    .blkb 2
                        .area idata
--- 0000 0001              .word 1
                        .area data
--- 0002                   .dbfile M:\Sysc 2003\Assignment 4/vectors_dp256_NoICE1.c
--- 0002                   .dbfile Assign44.C
--- 0002                   .dbsym e x _x I
 1002            _motorOn::
 1002                    .blkb 2
                        .area idata
--- 0002 0001              .word 1
                        .area data
--- 0004                   .dbfile Assign44.C
--- 0004                   .dbsym e motorOn _motorOn I
                        .area text
--- 0000                   .dbfile Assign44.C
--- 0000                   .dbfunc e main _main fV
--- 0000           ;           next -> -1,x
 402A            _main::
 402A  34                pshx
 402B  B775              tfr s,x
 402D  1B9E              leas -2,sp
 402F                    .dbline -1
 402F                    .dbline 19
 402F            ; /*
 402F            ; Authors Fady Ibrahim 100876906, Gavez Smith 100857991 
 402F            ; */
 402F            ; #include<stdio.h>
 402F            ; #include "hcs12dp256.h"
 402F            ; #include "vectors_dp256_NoICE1.c"
 402F            ; 
 402F            ; void delay();
 402F            ; char keypad();
 402F            ; #pragma interrupt_handler CollisionDetect()
 402F            ;  void CollisionDetect(void);
 402F            ;  #pragma interrupt_handler keyboardISR()
 402F            ;  void keyboardISR(void);
 402F            ; int x=1;
 402F            ; int motorOn=1;
 402F            ; char key;
 402F            ; 
 402F            ; void main(void)
 402F            ; {
 402F                    .dbline 21
 402F            ; char next;
 402F            ; Lcd2PP_Init();
 402F  164260            jsr _Lcd2PP_Init
 4032                    .dbline 22
 4032            ;     LCD_instruction();
 4032  164248            jsr _LCD_instruction
 4035                    .dbline 23
 4035            ;        LCD_display('P');
 4035  CC0050            ldd #80
 4038  164254            jsr _LCD_display
 403B                    .dbline 24
 403B            ;        LCD_display('R');
 403B  CC0052            ldd #82
 403E  164254            jsr _LCD_display
 4041                    .dbline 25
 4041            ;        LCD_display('E');
 4041  CC0045            ldd #69
 4044  164254            jsr _LCD_display
 4047                    .dbline 26
 4047            ;        LCD_display('S');
 4047  CC0053            ldd #83
 404A  164254            jsr _LCD_display
 404D                    .dbline 27
 404D            ;        LCD_display('S');
 404D  CC0053            ldd #83
 4050  164254            jsr _LCD_display
 4053                    .dbline 28
 4053            ;        LCD_display(' ');
 4053  CC0020            ldd #32
 4056  164254            jsr _LCD_display
 4059                    .dbline 29
 4059            ;        LCD_display('5');
 4059  CC0035            ldd #53
 405C  164254            jsr _LCD_display
 405F                    .dbline 30
 405F            ; SPI1CR1=0;
 405F  7900F0            clr 0xf0
 4062                    .dbline 31
 4062            ; key = 0xFF;
 4062  C6FF              ldab #255
 4064  7B1004            stab _key
 4067                    .dbline 32
 4067            ; DDRP |= 0x8F; // bitset PP0-3 as outputs (rows) 
 4067  1C025A8F          bset 0x25a,#143
 406B                    .dbline 33
 406B            ; DDRH &= 0x0F; // bitclear PH4..7 as inputs (columns)
 406B  1D0262F0          bclr 0x262,#0xf0
 406F                    .dbline 34
 406F            ; PTM=0x08;
 406F  C608              ldab #8
 4071  7B0250            stab 0x250
 4074                    .dbline 35
 4074            ; PTP = 0x8F; // Set scan row(s)
 4074  C68F              ldab #143
 4076  7B0258            stab 0x258
 4079                    .dbline 36
 4079            ; PIFH = 0xFF; // Clear previous interrupt flags
 4079  C6FF              ldab #255
 407B  7B0267            stab 0x267
 407E                    .dbline 37
 407E            ; PPSH = 0xF0; // Rising Edge
 407E  C6F0              ldab #240
 4080  7B0265            stab 0x265
 4083                    .dbline 38
 4083            ; PERH = 0x00; // Disable pulldowns
 4083  790264            clr 0x264
 4086                    .dbline 39
 4086            ; PIEH |= 0xF0; // Local enable on columns inputs
 4086  1C0266F0          bset 0x266,#240
 408A                    .dbline 40
 408A            ; asm( "cli" );
 408A  10EF                      cli
 408C            
 408C                    .dbline -2
 408C                    .dbline 43
 408C            ; 
 408C            ;       
 408C            ; }
 408C            L3:
 408C  B757              tfr x,s
 408E  30                pulx
 408F                    .dbline 0 ; func end
 408F  3D                rts
 4090                    .dbsym l next -1 c
 4090                    .dbend
 4090                    .dbfunc e CollisionDetect _CollisionDetect fV
 4090            ;      clockwise -> -4,x
 4090            _CollisionDetect::
 4090  34                pshx
 4091  B775              tfr s,x
 4093  1B9C              leas -4,sp
 4095                    .dbline -1
 4095                    .dbline 50
 4095            ; 
 4095            ; /*
 4095            ; This function is the Real-Time ISR and interruts the program when the user presses 5 on the keyboard. It executes the
 4095            ; interrupt turns off the dc motor waits 3-4 second and turns the steppor motor then afterwards it turns on the dc motor again.
 4095            ; */
 4095            ;  void CollisionDetect(void)
 4095            ; {
 4095                    .dbline 52
 4095            ; 
 4095            ;       if(motorOn==1)
 4095  FC1002            ldd _motorOn
 4098  8C0001            cpd #1
 409B  260A              bne L5
 409D                    .dbline 53
 409D            ;       {
 409D                    .dbline 54
 409D            ;       motorOn=0;
 409D  CC0000            ldd #0
 40A0  7C1002            std _motorOn
 40A3                    .dbline 55
 40A3            ;       PTP=PTP & 0x7F;
 40A3  1D025880          bclr 0x258,#0x80
 40A7                    .dbline 56
 40A7            ;       }       
 40A7            L5:
 40A7                    .dbline 57
 40A7            ; if (x==24)
 40A7  FC1000            ldd _x
 40AA  8C0018            cpd #24
 40AD  265D              bne L7
 40AF                    .dbline 58
 40AF            ; {
 40AF                    .dbline 59
 40AF            ; double clockwise =0;   //counter clockwise incrementer
 40AF  CD4389            ldy #L9
 40B2  1644F9            jsr __tofp1
 40B5  191C              leay -4,x
 40B7  1644F1            jsr __fromfp1
 40BA                    .dbline 61
 40BA            ; 
 40BA            ;       DDRP = 0xF0;//enable port P for the stepper motor
 40BA  C6F0              ldab #240
 40BC  7B025A            stab 0x25a
 40BF                    .dbline 62
 40BF            ;       PTP = 0x20;
 40BF  C620              ldab #32
 40C1  7B0258            stab 0x258
 40C4                    .dbline 63
 40C4            ;       DDRT = 0xF0;//enable the bottom and left coils for the stepper motor
 40C4  C6F0              ldab #240
 40C6  7B0242            stab 0x242
 40C9  2031              bra L11
 40CB            L10:
 40CB                    .dbline 65
 40CB                    .dbline 66
 40CB  C680              ldab #128
 40CD  7B0240            stab 0x240
 40D0                    .dbline 67
 40D0  1641CF            jsr _delay
 40D3                    .dbline 68
 40D3  C620              ldab #32
 40D5  7B0240            stab 0x240
 40D8                    .dbline 69
 40D8  1641CF            jsr _delay
 40DB                    .dbline 70
 40DB  C640              ldab #64
 40DD  7B0240            stab 0x240
 40E0                    .dbline 71
 40E0  1641CF            jsr _delay
 40E3                    .dbline 72
 40E3  790240            clr 0x240
 40E6                    .dbline 73
 40E6  1641CF            jsr _delay
 40E9                    .dbline 74
 40E9  191C              leay -4,x
 40EB  1644F9            jsr __tofp1
 40EE  CD4385            ldy #L13
 40F1  164501            jsr __tofp2
 40F4  164522            jsr __fpadd
 40F7  191C              leay -4,x
 40F9  1644F1            jsr __fromfp1
 40FC                    .dbline 75
 40FC            L11:
 40FC                    .dbline 65
 40FC            ;       
 40FC            ;       while(clockwise<=5){//spin the stepper motor clockwise
 40FC  191C              leay -4,x
 40FE  1644F9            jsr __tofp1
 4101  CD4381            ldy #L14
 4104  164501            jsr __tofp2
 4107  16463D            jsr __fpcmp
 410A  2FBF              ble L10
 410C                    .dbline 76
 410C            ;          PTT = 0x80;
 410C            ;          delay();
 410C            ;          PTT = 0x20;
 410C            ;          delay();
 410C            ;          PTT = 0x40;
 410C            ;          delay();
 410C            ;          PTT = 0x00;
 410C            ;          delay();
 410C            ;          clockwise++;
 410C            ;       }
 410C            ; }
 410C            L7:
 410C                    .dbline 77
 410C            ; if (x==40)
 410C  FC1000            ldd _x
 410F  8C0028            cpd #40
 4112  2610              bne L15
 4114                    .dbline 78
 4114            ; {
 4114                    .dbline 79
 4114            ;       motorOn=1;
 4114  CC0001            ldd #1
 4117  7C1002            std _motorOn
 411A                    .dbline 80
 411A            ;       x=0;
 411A  CC0000            ldd #0
 411D  7C1000            std _x
 4120                    .dbline 81
 4120            ;       CRGINT= CRGINT & 0x7F;
 4120  1D003880          bclr 0x38,#0x80
 4124                    .dbline 82
 4124            ; }
 4124            L15:
 4124                    .dbline 83
 4124            ;  CRGFLG|= 0x80;
 4124  1C003780          bset 0x37,#128
 4128                    .dbline 84
 4128            ; x++;
 4128  FC1000            ldd _x
 412B  C30001            addd #1
 412E  7C1000            std _x
 4131                    .dbline -2
 4131                    .dbline 85
 4131            ; } 
 4131            L4:
 4131  B757              tfr x,s
 4133  30                pulx
 4134                    .dbline 0 ; func end
 4134  0B                rti
 4135                    .dbsym l clockwise -4 D
 4135                    .dbend
 4135                    .dbfunc e keyboardISR _keyboardISR fV
 4135            ;           temp -> -1,x
 4135            _keyboardISR::
 4135  34                pshx
 4136  B775              tfr s,x
 4138  1B9E              leas -2,sp
 413A                    .dbline -1
 413A                    .dbline 89
 413A            ; 
 413A            ; 
 413A            ; void keyboardISR(void)
 413A            ; {
 413A                    .dbline 91
 413A            ; char temp;
 413A            ; PIEH = 0x00; // Local disable
 413A  790266            clr 0x266
 413D                    .dbline 92
 413D            ; PIFH = PIFH; // Acknowledge (all) interrupts
 413D                    ; vol
 413D  F60267            ldab 0x267
 4140  7B0267            stab 0x267
 4143                    .dbline 93
 4143            ; PIEH |= 0xF0; // Local enable on columns inputs
 4143  1C0266F0          bset 0x266,#240
 4147                    .dbline 94
 4147            ; asm("SEI");
 4147  1410                      SEI
 4149            
 4149                    .dbline 95
 4149            ; temp = keypad();
 4149  1641F0            jsr _keypad
 414C  6B1F              stab -1,x
 414E                    .dbline 96
 414E            ; if (temp ==0x35) 
 414E  E61F              ldab -1,x
 4150  C135              cmpb #53
 4152  2666              bne L18
 4154                    .dbline 97
 4154            ; {
 4154                    .dbline 98
 4154            ;       printf ("Obstacle detected. Robot turing right in three seconds (Look at stepper motor)!\n");   
 4154  CC4330            ldd #L20
 4157  164CF5            jsr _printf
 415A                    .dbline 99
 415A            ;         LCD_instruction(0x00);
 415A  CC0000            ldd #0
 415D  164248            jsr _LCD_instruction
 4160                    .dbline 100
 4160            ;        LCD_display('T');
 4160  CC0054            ldd #84
 4163  164254            jsr _LCD_display
 4166                    .dbline 101
 4166            ;        LCD_display('U');
 4166  CC0055            ldd #85
 4169  164254            jsr _LCD_display
 416C                    .dbline 102
 416C            ;        LCD_display('R');
 416C  CC0052            ldd #82
 416F  164254            jsr _LCD_display
 4172                    .dbline 103
 4172            ;        LCD_display('N');
 4172  CC004E            ldd #78
 4175  164254            jsr _LCD_display
 4178                    .dbline 104
 4178            ;        LCD_display('I');
 4178  CC0049            ldd #73
 417B  164254            jsr _LCD_display
 417E                    .dbline 105
 417E            ;        LCD_display('N');
 417E  CC004E            ldd #78
 4181  164254            jsr _LCD_display
 4184                    .dbline 106
 4184            ;        LCD_display('G');
 4184  CC0047            ldd #71
 4187  164254            jsr _LCD_display
 418A                    .dbline 107
 418A            ;        LCD_display(' ');
 418A  CC0020            ldd #32
 418D  164254            jsr _LCD_display
 4190                    .dbline 108
 4190            ;        LCD_display('R');
 4190  CC0052            ldd #82
 4193  164254            jsr _LCD_display
 4196                    .dbline 109
 4196            ;        LCD_display('I');
 4196  CC0049            ldd #73
 4199  164254            jsr _LCD_display
 419C                    .dbline 110
 419C            ;        LCD_display('G');
 419C  CC0047            ldd #71
 419F  164254            jsr _LCD_display
 41A2                    .dbline 111
 41A2            ;        LCD_display('H');
 41A2  CC0048            ldd #72
 41A5  164254            jsr _LCD_display
 41A8                    .dbline 112
 41A8            ;        LCD_display('T');
 41A8  CC0054            ldd #84
 41AB  164254            jsr _LCD_display
 41AE                    .dbline 113
 41AE            ;       CRGINT=0x80; //enable realtime interrupt
 41AE  C680              ldab #128
 41B0  7B0038            stab 0x38
 41B3                    .dbline 114
 41B3            ;       RTICTL=0x7F;// set the period frequency.
 41B3  C67F              ldab #127
 41B5  7B003B            stab 0x3b
 41B8                    .dbline 115
 41B8            ;       asm("cli");
 41B8  10EF                      cli
 41BA            
 41BA                    .dbline 116
 41BA            ;  }
 41BA            L18:
 41BA                    .dbline 117
 41BA            ;  PTP=0x80;
 41BA  C680              ldab #128
 41BC  7B0258            stab 0x258
 41BF                    .dbline 118
 41BF            ;  PIFH = PIFH; // Acknowledge (all) interrupts
 41BF                    ; vol
 41BF  F60267            ldab 0x267
 41C2  7B0267            stab 0x267
 41C5                    .dbline 119
 41C5            ; PIEH |= 0xF0; // Local enable on columns inputs
 41C5  1C0266F0          bset 0x266,#240
 41C9                    .dbline 120
 41C9            ;       asm("cli");
 41C9  10EF                      cli
 41CB            
 41CB                    .dbline -2
 41CB                    .dbline 121
 41CB            ; }
 41CB            L17:
 41CB  B757              tfr x,s
 41CD  30                pulx
 41CE                    .dbline 0 ; func end
 41CE  0B                rti
 41CF                    .dbsym l temp -1 c
 41CF                    .dbend
 41CF                    .dbfunc e delay _delay fV
 41CF            ;              i -> -2,x
 41CF            _delay::
 41CF  34                pshx
 41D0  B775              tfr s,x
 41D2  1B9E              leas -2,sp
 41D4                    .dbline -1
 41D4                    .dbline 123
 41D4            ; 
 41D4            ; void delay(){//delay for a considerable 10 ms
 41D4                    .dbline 124
 41D4            ;    int i = 0;   //counter
 41D4  CC0000            ldd #0
 41D7  6C1E              std -2,x
 41D9                    .dbline 125
 41D9  CC0000            ldd #0
 41DC  6C1E              std -2,x
 41DE            L22:
 41DE                    .dbline 125
 41DE                    .dbline 126
 41DE            L23:
 41DE                    .dbline 125
 41DE            ;    for(i=0; i<10000; i++){
 41DE  EC1E              ldd -2,x
 41E0  C30001            addd #1
 41E3  6C1E              std -2,x
 41E5                    .dbline 125
 41E5  EC1E              ldd -2,x
 41E7  8C2710            cpd #10000
 41EA  2DF2              blt L22
 41EC                    .dbline -2
 41EC                    .dbline 127
 41EC            ;    }
 41EC            ; }
 41EC            L21:
 41EC  B757              tfr x,s
 41EE  30                pulx
 41EF                    .dbline 0 ; func end
 41EF  3D                rts
 41F0                    .dbsym l i -2 I
 41F0                    .dbend
 41F0                    .dbfunc e keypad _keypad fc
 41F0            ;           loop -> -3,x
 41F0            ;     keypressed -> -1,x
 41F0            _keypad::
 41F0  34                pshx
 41F1  B775              tfr s,x
 41F3  1B9C              leas -4,sp
 41F5                    .dbline -1
 41F5                    .dbline 130
 41F5            ; 
 41F5            ; char keypad()
 41F5            ; {
 41F5                    .dbline 131
 41F5            ;       int loop=0;
 41F5  CC0000            ldd #0
 41F8  6C1D              std -3,x
 41FA                    .dbline 132
 41FA            ;       char keypressed=0;
 41FA  691F              clr -1,x
 41FC  2042              bra L28
 41FE            L27:
 41FE                    .dbline 134
 41FE            ;       while (loop==0)
 41FE            ;       {
 41FE                    .dbline 136
 41FE            ;       // turns on the motor and the the output pins for the rows on the keypad.
 41FE            ;       DDRP=0x8F;
 41FE  C68F              ldab #143
 4200  7B025A            stab 0x25a
 4203                    .dbline 138
 4203            ;       //turns on the collums.
 4203            ;       DDRH=0x00;      
 4203  790262            clr 0x262
 4206                    .dbline 139
 4206            ;       PTM = 0x08;
 4206  C608              ldab #8
 4208  7B0250            stab 0x250
 420B                    .dbline 140
 420B            ;       if(motorOn==1)
 420B  FC1002            ldd _motorOn
 420E  8C0001            cpd #1
 4211  2604              bne L30
 4213                    .dbline 141
 4213            ;       {
 4213                    .dbline 142
 4213            ;       PTP=PTP | 0x80;
 4213  1C025880          bset 0x258,#128
 4217                    .dbline 143
 4217            ;       }                                                       
 4217            L30:
 4217                    .dbline 144
 4217            ;       keypressed=PTH;
 4217                    ; vol
 4217  F60260            ldab 0x260
 421A  6B1F              stab -1,x
 421C                    .dbline 145
 421C            ;       PTP= PTP & 0x82;
 421C  1D02587D          bclr 0x258,#0x7d
 4220                    .dbline 146
 4220            ;       PTM =PTM & 0x00;
 4220  CC0000            ldd #0
 4223  7B0250            stab 0x250
 4226                    .dbline 147
 4226            ;       keypressed &= 0xF0;
 4226  0D1F0F            bclr -1,x,#0xf
 4229                    .dbline 148
 4229            ;       if (keypressed==0x20 && PTP==0x82)
 4229  E61F              ldab -1,x
 422B  C120              cmpb #32
 422D  260C              bne L32
 422F                    ; vol
 422F  F60258            ldab 0x258
 4232  C182              cmpb #130
 4234  2605              bne L32
 4236                    .dbline 149
 4236            ;       {
 4236                    .dbline 150
 4236            ;        return '5';
 4236  CC0035            ldd #53
 4239  2009              bra L26
 423B            L32:
 423B                    .dbline 153
 423B  CC0000            ldd #0
 423E  2004              bra L26
 4240            L28:
 4240                    .dbline 133
 4240  EC1D              ldd -3,x
 4242  27BA              beq L27
 4244                    .dbline -2
 4244                    .dbline 157
 4244            ;       }
 4244            ; 
 4244            ;       return 0;
 4244            ;       
 4244            ; 
 4244            ; }
 4244            ; }
 4244            L26:
 4244  B757              tfr x,s
 4246  30                pulx
 4247                    .dbline 0 ; func end
 4247  3D                rts
 4248                    .dbsym l loop -3 I
 4248                    .dbsym l keypressed -1 c
 4248                    .dbend
 0000            REGBS = $0000 ; DP256 register bank base address
 0000            PORTA = REGBS+0 ;port A = Address lines A8 A15
 0001            PORTB = REGBS+1 ;port B = Address lines A0 A7
 0002            DDRA = REGBS+2 ;port A direction register
 0003            DDRB = REGBS+3 ;port A direction register
 0008            PORTE = REGBS+8 ;port E = mode,IRQandcontrolsignals
 0009            DDRE = REGBS+9 ;port E direction register
 000A            PEAR = REGBS+$A ;port E assignments
 000B            MODE = REGBS+$B ;Mode register
 000C            PUCR = REGBS+$C ;port pull-up control register
 000D            RDRIV = REGBS+$D ;port reduced drive control register
 000E            EBICTL = REGBS+$E ;E stretch control
 4248            
 0010            INITRM = REGBS+$10 ;Ram location register
 0011            INITRG = REGBS+$11 ;Register location register
 0012            INITEE = REGBS+$12 ;EEprom location register
 0013            MISC = REGBS+$13 ;MiscellaneoMapping control
 0014            MTST0 = REGBS+$14 ; RESERVED
 0015            ITCR = REGBS+$15 ;Interrupt test control register
 0016            ITEST = REGBS+$16 ;Interrupt test register
 0017            MTST1 = REGBS+$17 ; Reserved
 4248            
 001A            PARTIDH = REGBS+$1A ;Part ID high
 001B            PARTIDL = REGBS+$1B ;Part ID low
 001C            MEMSIZ0 = REGBS+$1C ;memory size
 001D            MEMSIZ1 = REGBS+$1D ;memory size
 001E            INTCR = REGBS+$1E ;interrupt control register
 001F            HPRIO = REGBS+$1F ;high priority reg
 4248            
 0028            BKPCT0 = REGBS+$28 ;Break control register
 0029            BKPCT1 = REGBS+$29 ;Break control register
 002A            BKP0X = REGBS+$2A ; Break 0 index register
 002B            BKP0H = REGBS+$2B ; Break 0 pointer high
 002C            BRP0L = REGBS+$2C ; Break 0 pointer low
 002D            BKP1X = REGBS+$2D ; Break 1 index register
 002E            BKP1H = REGBS+$2E ; Break 1 pointer high
 002F            BRP1L = REGBS+$2F ; Break 1 pointer low
 0030            PPAGE = REGBS+$30 ;Program Page register
 4248            
 0032            PORTK = REGBS+$32 ;Port K data
 0033            DDRK = REGBS+$33 ;Port K direction
 0034            SYNR = REGBS+$34 ; Synthesizer / multiplier register
 0035            REFDV = REGBS+$35 ; Reference divider register
 0036            CTFLG = REGBS+$36 ; RESERVED
 0037            CRGFLG = REGBS+$37 ; PLL flags register
 0038            CRGINT = REGBS+$38 ; PLL interrupt register
 0039            CLKSEL = REGBS+$39 ; Clock select register
 003A            PLLCTL = REGBS+$3A ; PLL control register
 003B            RTICTL = REGBS+$3B ;Real time interrupt control
 003C            COPCTL = REGBS+$3C ;Watchdog control
 003D            FORBYP = REGBS+$3D ;
 003E            CTCTL = REGBS+$3E ;
 003F            ARMCOP = REGBS+$3F ;COP reset register
 4248            
 0040            TIOS = REGBS+$40 ;timer input/output select
 0041            CFORC = REGBS+$41 ;timer compare force
 0042            OC7M = REGBS+$42 ;timer output compare 7 mask
 0043            OC7D = REGBS+$43 ;timer output compare 7 data
 0044            TCNT = REGBS+$44 ;timer counter register hi
 0045            *TCNT = REGBS+$45 ;timer counter register lo
 0046            TSCR = REGBS+$46 ;timer system control register
 0047            TTOV = REGBS+$47 ;reserved
 0048            TCTL1 = REGBS+$48 ;timer control register 1
 0049            TCTL2 = REGBS+$49 ;timer control register 2
 004A            TCTL3 = REGBS+$4A ;timer control register 3
 004B            TCTL4 = REGBS+$4B ;timer control register 4
 004C            TMSK1 = REGBS+$4C ;timer interrupt mask 1
 004D            TMSK2 = REGBS+$4D ;timer interrupt mask 2
 004E            TFLG1 = REGBS+$4E ;timer flags 1
 004F            TFLG2 = REGBS+$4F ;timer flags 2
 0050            TC0 = REGBS+$50 ;timer capture/comparregister 0
 0051            *TC0 = REGBS+$51 ;
 0052            TC1 = REGBS+$52 ;timer capture/comparregister 1
 0053            *TC1 = REGBS+$53 ;
 0054            TC2 = REGBS+$54 ;timer capture/comparregister 2
 0055            *TC2 = REGBS+$55 ;
 0056            TC3 = REGBS+$56 ;timer capture/comparregister 3
 0057            *TC3 = REGBS+$57 ;
 0058            TC4 = REGBS+$58 ;timer capture/comparregister 4
 0059            *TC4 = REGBS+$59 ;
 005A            TC5 = REGBS+$5A ;timer capture/comparregister 5
 005B            *TC5 = REGBS+$5B ;
 005C            TC6 = REGBS+$5C ;timer capture/comparregister 6
 005D            *TC6 = REGBS+$5D ;
 005E            TC7 = REGBS+$5E ;timer capture/comparregister 7
 005F            *TC7 = REGBS+$5F ;
 0060            PACTL = REGBS+$60 ;pulse accumulator controls
 0061            PAFLG = REGBS+$61 ;pulse accumulator flags
 0062            PACN3 = REGBS+$62 ;pulse accumulator counter 3
 0063            PACN2 = REGBS+$63 ;pulse accumulator counter 2
 0064            PACN1 = REGBS+$64 ;pulse accumulator counter 1
 0065            PACN0 = REGBS+$65 ;pulse accumulator counter 0
 0066            MCCTL = REGBS+$66 ;Modulus down conunter control
 0067            MCFLG = REGBS+$67 ;down counter flags
 0068            ICPAR = REGBS+$68 ;Input pulse accumulatocontrol
 0069            DLYCT = REGBS+$69 ;Delay count to down counter
 006A            ICOVW = REGBS+$6A ;Input control overwrite register
 006B            ICSYS = REGBS+$6B ;Input control system control
 4248            
 006D            TIMTST = REGBS+$6D ;timer test register
 4248            
 0070            PBCTL = REGBS+$70 ; Pulse accumulatoB control
 0071            PBFLG = REGBS+$71 ; Pulse accumulatoB flags
 0072            PA3H = REGBS+$72 ; Pulse Accumulatoholding regist3
 0073            PA2H = REGBS+$73 ; Pulse Accumulatoholding regist2
 0074            PA1H = REGBS+$74 ; Pulse Accumulatoholding regist1
 0075            PA0H = REGBS+$75 ; Pulse Accumulatoholding regist0
 0076            MCCNT = REGBS+$76 ; Modulus down counter register
 0077            *MCCNTL = REGBS+$77 ; low byte
 0078            TCOH = REGBS+$78 ; Capture 0 holding register
 007A            TC1H = REGBS+$7A ; Capture 1 holding register
 007C            TC2H = REGBS+$7C ; Capture 2 holding register
 007E            TC3H = REGBS+$7E ; Capture 3 holding register
 4248            
 0080            ATD0CTL0 = REGBS+$80 ;ADC control 0 (reserved)
 0081            ATD0CTL1 = REGBS+$81 ;ADC control 1 (reserved)
 0082            ATD0CTL2 = REGBS+$82 ;ADC control 2
 0083            ATD0CTL3 = REGBS+$83 ;ADC control 3
 0084            ATD0CTL4 = REGBS+$84 ;ADC control 4
 0085            ATD0CTL5 = REGBS+$85 ;ADC control 5
 0086            ATD0STAT = REGBS+$86 ;ADC status register hi
 0087            *ATD0STAT = REGBS+$87 ;ADC status register lo
 0088            ATD0TEST = REGBS+$88 ;ADC test (reserved)
 0089            *ATD0TEST = REGBS+$89 ;
 4248            
 008D            ATD0DIEN = REGBS+$8D ;
 4248            
 008F            PORTAD = REGBS+$8F ;port ADC = input only
 0090            ADR00H = REGBS+$90 ;ADC result 0 register
 0092            ADR01H = REGBS+$92 ;ADC result 1 register
 0094            ADR02H = REGBS+$94 ;ADC result 2 register
 0096            ADR03H = REGBS+$96 ;ADC result 3 register
 0098            ADR04H = REGBS+$98 ;ADC result 4 register
 009A            ADR05H = REGBS+$9A ;ADC result 5 register
 009C            ADR06H = REGBS+$9C ;ADC result 6 register
 009E            ADR07H = REGBS+$9E ;ADC result 7 register
 4248            
 00A0            PWME = REGBS+$A0 ;PWM enable
 00A1            PWMPOL = REGBS+$A1 ;PWM polarity
 00A2            PWMCLK = REGBS+$A2 ;PWM clock select register
 00A3            PWMPRCLK = REGBS+$A3 ;PWM Prescale clock select register
 00A4            PWMCAE = REGBS+$A4 ;PWM center align select register
 00A5            PWMCTL = REGBS+$A5 ;PWM control register
 00A6            PWMTST = REGBS+$A6 ;reserved
 00A7            PWMPRSC = REGBS+$A7 ;reserved
 00A8            PWMSCLA = REGBS+$A8 ;PWM Scale A
 00A9            PWMSCLB = REGBS+$A9 ;PWM scale B
 00AA            PWMSCNTA = REGBS+$AA ;reserved
 00AB            PWMSCNTB = REGBS+$AB ;reserved
 00AC            PWMCNT0 = REGBS+$AC ;PWM channel 0 counter
 00AD            PWMCNT1 = REGBS+$AD ;PWM channel 1 counter
 00AE            PWMCNT2 = REGBS+$AE ;PWM channel 2 counter
 00AF            PWMCNT3 = REGBS+$AF ;PWM channel 3 counter
 00B0            PWMCNT4 = REGBS+$B0 ;PWM channel 4 counter
 00B1            PWMCNT5 = REGBS+$B1 ;PWM channel 5 counter
 00B2            PWMCNT6 = REGBS+$B2 ;PWM channel 6 counter
 00B3            PWMCNT7 = REGBS+$B3 ;PWM channel 7 counter
 00B4            PWMPER0 = REGBS+$B4 ;PWM channel 0 period
 00B5            PWMPER1 = REGBS+$B5 ;PWM channel 1 period
 00B6            PWMPER2 = REGBS+$B6 ;PWM channel 2 period
 00B7            PWMPER3 = REGBS+$B7 ;PWM channel 3 period
 00B8            PWMPER4 = REGBS+$B8 ;PWM channel 4 period
 00B9            PWMPER5 = REGBS+$B9 ;PWM channel 5 period
 00BA            PWMPER6 = REGBS+$BA ;PWM channel 6 period
 00BB            PWMPER7 = REGBS+$BB ;PWM channel 7 period
 00BC            PWMDTY0 = REGBS+$BC ;PWM channel 0 duty cycle
 00BD            PWMDTY1 = REGBS+$BD ;PWM channel 1 duty cycle
 00BE            PWMDTY2 = REGBS+$BE ;PWM channel 2 duty cycle
 00BF            PWMDTY3 = REGBS+$BF ;PWM channel 3 duty cycle
 00C0            PWMDTY4 = REGBS+$C0 ;PWM channel 0 duty cycle
 00C1            PWMDTY5 = REGBS+$C1 ;PWM channel 1 duty cycle
 00C2            PWMDTY6 = REGBS+$C2 ;PWM channel 2 duty cycle
 00C3            PWMDTY7 = REGBS+$C3 ;PWM channel 3 duty cycle
 00C4            PWMSDN = REGBS+$C4 ;PWM shutdown register
 4248            
 00C8            SC0BDH = REGBS+$C8 ;sci 0 baud reg hi byte
 00C9            SC0BDL = REGBS+$C9 ;sci 0 baud reg lo byte
 00CA            SC0CR1 = REGBS+$CA ;sci 0 control1 reg
 00CB            SC0CR2 = REGBS+$CB ;sci 0 control2 reg
 00CC            SC0SR1 = REGBS+$CC ;sci 0 status reg 1
 00CD            SC0SR2 = REGBS+$CD ;sci 0 status reg 2
 00CE            SC0DRH = REGBS+$CE ;sci 0 data reg hi
 00CF            SC0DRL = REGBS+$CF ;sci 0 data reg lo
 00D0            SC1BDH = REGBS+$D0 ;sci 1 baud reg hi byte
 00D1            SC1BDL = REGBS+$D1 ;sci 1 baud reg lo byte
 00D2            SC1CR1 = REGBS+$D2 ;sci 1 control1 reg
 00D3            SC1CR2 = REGBS+$D3 ;sci 1 control2 reg
 00D4            SC1SR1 = REGBS+$D4 ;sci 1 status reg 1
 00D5            SC1SR2 = REGBS+$D5 ;sci 1 status reg 2
 00D6            SC1DRH = REGBS+$D6 ;sci 1 data reg hi
 00D7            SC1DRL = REGBS+$D7 ;sci 1 data reg lo
 00D8            SPI0CR1 = REGBS+$D8 ;spi 0 control1 reg
 00D9            SPI0CR2 = REGBS+$D9 ;spi 0 control2 reg
 00DA            SPI0BR = REGBS+$DA ;spi 0 baud reg
 00DB            SPI0SR = REGBS+$DB ;spi 0 status reg hi
 4248            
 00DD            SP0DR = REGBS+$DD ;spi 0 data reg
 4248            
 00E0            IBAD = REGBS+$E0 ;I2C Bus address register
 00E1            IBFD = REGBS+$E1 ;I2C Bus fr=ency divider
 00E2            IBCR = REGBS+$E2 ;I2C Bus control register
 00E3            IBSR = REGBS+$E3 ;I2C Bus status register
 00E4            IBDR = REGBS+$E4 ;I2C Bus message data register
 4248            
 00E8            DLCBCR1 = REGBS+$E8 ;BDLC Control regsiter 1
 00E9            DLCBSVR = REGBS+$E9 ;BDLC State vector register
 00EA            DLCBCR2 = REGBS+$EA ;BDLC Control register 2
 00EB            DLCBDR = REGBS+$EB ;BDLC Data register
 00EC            DLCBARD = REGBS+$EC ;BDLC Analog delay register
 00ED            DLCBRSR = REGBS+$ED ;BDLC Rate select register
 00EE            DLCSCR = REGBS+$EE ;BDLC Control register
 00EF            DLCBSTAT = REGBS+$EF ;BDLC Status register
 00F0            SPI1CR1 = REGBS+$F0 ;spi 1 control1 reg
 00F1            SPI1CR2 = REGBS+$F1 ;spi 1 control2 reg
 00F2            SPI1BR = REGBS+$F2 ;spi 1 baud reg
 00F3            SPI1SR = REGBS+$F3 ;spi 1 status reg hi
 4248            
 00F5            SP1DR = REGBS+$F5 ;spi 1 data reg
 4248            
 00F8            SPI2CR1 = REGBS+$F8 ;spi 2 control1 reg
 00F9            SPI2CR2 = REGBS+$F9 ;spi 2 control2 reg
 00FA            SPI2BR = REGBS+$FA ;spi 2 baud reg
 00FB            SPI2SR = REGBS+$FB ;spi 2 status reg hi
 4248            
 00FD            SP2DR = REGBS+$FD ;spi 2 data reg
 4248            
 0100            FCLKDIV = REGBS+$100 ;FLASH clock divider
 0101            FSEC = REGBS+$101 ;FLASH security register
 4248            
 0103            FCNFG = REGBS+$103 ;FLASH configuration register
 0104            FPROT = REGBS+$104 ;FLASH protection register
 0105            FSTAT = REGBS+$105 ;FLASH status register
 0106            FCMD = REGBS+$106 ;FLASH command register
 4248            
 0110            ECLKDIV = REGBS+$110 ;EEPROM clock divider
 4248            
 0113            ECNFG = REGBS+$113 ;EEPROM configuration register
 0114            EPROT = REGBS+$114 ;EEPROM protection register
 0115            ESTAT = REGBS+$115 ;EEPROM status register
 0116            ECMD = REGBS+$116 ;EEPROM command register
 4248            
 0120            ATD1CTL0 = REGBS+$120 ;ADC1 control 0 (reserved)
 0121            ATD1CTL1 = REGBS+$121 ;ADC1 control 1 (reserved)
 0122            ATD1CTL2 = REGBS+$122 ;ADC1 control 2
 0123            ATD1CTL3 = REGBS+$123 ;ADC1 control 3
 0124            ATD1CTL4 = REGBS+$124 ;ADC1 control 4
 0125            ATD1CTL5 = REGBS+$125 ;ADC1 control 5
 0126            ATD1STAT = REGBS+$126 ;ADC1 status register hi
 0127            *ATD1STAT = REGBS+$127 ;ADC1 status register lo
 0128            ATD1TEST = REGBS+$128 ;ADC1 test (reserved)
 0129            *ATD1TEST = REGBS+$129 ;
 4248            
 012D            ATDDIEN = REGBS+$12D ;ADC1 INPUT ENABLE REGISTER
 4248            
 012F            PORTAD1 = REGBS+$12F ;port ADC1 = input only
 0130            ADR10H = REGBS+$130 ;ADC1 result 0 register
 0132            ADR11H = REGBS+$132 ;ADC1 result 1 register
 0134            ADR12H = REGBS+$134 ;ADC1 result 2 register
 0136            ADR13H = REGBS+$136 ;ADC1 result 3 register
 0138            ADR14H = REGBS+$138 ;ADC1 result 4 register
 013A            ADR15H = REGBS+$13A ;ADC1 result 5 register
 013C            ADR16H = REGBS+$13C ;ADC1 result 6 register
 013E            ADR17H = REGBS+$13E ;ADC1 result 7 register
 0140            CAN0CTL0 = REGBS+$140 ;CAN0 control register 0
 0141            CAN0CTL1 = REGBS+$141 ;CAN0 control register 1
 0142            CAN0BTR0 = REGBS+$142 ;CAN0 bus timing register 0
 0143            CAN0BTR1 = REGBS+$143 ;CAN0 bus timing register 1
 0144            CAN0RFLG = REGBS+$144 ;CAN0 receiver flags
 0145            CAN0RIER = REGBS+$145 ;CAN0 receiver interrupt enables
 0146            CAN0TFLG = REGBS+$146 ;CAN0 transmit flags
 0147            CAN0TIER = REGBS+$147 ;CAN0 transmit interrupt enables
 0148            CAN0TARQ = REGBS+$148 ;CAN0 transmit message abort control
 0149            CAN0TAAK = REGBS+$149 ;CAN0 transmit message abort status
 014A            CAN0TBEL = REGBS+$14A ;CAN0 transmit buffer select
 014B            CAN0IDAC = REGBS+$14B ;CAN0 identfier acceptancecontrol
 4248            
 014E            CAN0RERR = REGBS+$14E ;CAN0 Receive error counter
 014F            CAN0TERR = REGBS+$14F ;CAN0 Transmit error counter
 0150            CAN0IDA0 = REGBS+$150 ;CAN0 Identifier acceptanceregister 0
 0151            CAN0IDA1 = REGBS+$151 ;CAN0 Identifier acceptanceregister 1
 0152            CAN0IDA2 = REGBS+$152 ;CAN0 Identifier acceptanceregister 2
 0153            CAN0IDA3 = REGBS+$153 ;CAN0 Identifier acceptanceregister 3
 0154            CAN0IDM0 = REGBS+$154 ;CAN0 Identifier mask register 0
 0155            CAN0IDM1 = REGBS+$155 ;CAN0 Identifier mask register 1
 0156            CAN0IDM2 = REGBS+$156 ;CAN0 Identifier mask register 2
 0157            CAN0IDM3 = REGBS+$157 ;CAN0 Identifier mask register 3
 0158            CAN0IDA4 = REGBS+$158 ;CAN0 Identifier acceptanceregister 4
 0159            CAN0IDA5 = REGBS+$159 ;CAN0 Identifier acceptanceregister 5
 015A            CAN0IDA6 = REGBS+$15A ;CAN0 Identifier acceptanceregister 6
 015B            CAN0IDA7 = REGBS+$15B ;CAN0 Identifier acceptanceregister 7
 015C            CAN0IDM4 = REGBS+$15C ;CAN0 Identifier mask register 4
 015D            CAN0IDM5 = REGBS+$15D ;CAN0 Identifier mask register 5
 015E            CAN0IDM6 = REGBS+$15E ;CAN0 Identifier mask register 6
 015F            CAN0IDM7 = REGBS+$15F ;CAN0 Identifier mask register 7
 0160            CAN0RXFG = REGBS+$160 ;CAN0 RX foregroundbuffer thru +$16F
 0170            CAN0TXFG = REGBS+$170 ;CAN0 TX foregroundbuffer thru +$17F
 4248            
 0180            CAN1CTL0 = REGBS+$180 ;CAN1 control register 0
 0181            CAN1CTL1 = REGBS+$181 ;CAN1 control register 1
 0182            CAN1BTR0 = REGBS+$182 ;CAN1 bus timing register 0
 0183            CAN1BTR1 = REGBS+$183 ;CAN1 bus timing register 1
 0184            CAN1RFLG = REGBS+$184 ;CAN1 receiver flags
 0185            CAN1RIER = REGBS+$185 ;CAN1 receiver interrupt enables
 0186            CAN1TFLG = REGBS+$186 ;CAN1 transmit flags
 0187            CAN1TIER = REGBS+$187 ;CAN1 transmit interrupt enables
 0188            CAN1TARQ = REGBS+$188 ;CAN1 transmit message abort control
 0189            CAN1TAAK = REGBS+$189 ;CAN1 transmit message abort status
 018A            CAN1TBEL = REGBS+$18A ;CAN1 transmit buffer select
 018B            CAN1IDAC = REGBS+$18B ;CAN1 identfier acceptancecontrol
 4248            
 018E            CAN1RERR = REGBS+$18E ;CAN1 Receive error counter
 018F            CAN1TERR = REGBS+$18F ;CAN1 Transmit error counter
 0190            CAN1IDA0 = REGBS+$190 ;CAN1 Identifier acceptanceregister 0
 0191            CAN1IDA1 = REGBS+$191 ;CAN1 Identifier acceptanceregister 1
 0192            CAN1IDA2 = REGBS+$192 ;CAN1 Identifier acceptanceregister 2
 0193            CAN1IDA3 = REGBS+$193 ;CAN1 Identifier acceptanceregister 3
 0194            CAN1IDM0 = REGBS+$194 ;CAN1 Identifier mask register 0
 0195            CAN1IDM1 = REGBS+$195 ;CAN1 Identifier mask register 1
 0196            CAN1IDM2 = REGBS+$196 ;CAN1 Identifier mask register 2
 0197            CAN1IDM3 = REGBS+$197 ;CAN1 Identifier mask register 3
 0198            CAN1IDA4 = REGBS+$198 ;CAN1 Identifier acceptanceregister 4
 0199            CAN1IDA5 = REGBS+$199 ;CAN1 Identifier acceptanceregister 5
 019A            CAN1IDA6 = REGBS+$19A ;CAN1 Identifier acceptanceregister 6
 019B            CAN1IDA7 = REGBS+$19B ;CAN1 Identifier acceptanceregister 7
 019C            CAN1IDM4 = REGBS+$19C ;CAN1 Identifier mask register 4
 019D            CAN1IDM5 = REGBS+$19D ;CAN1 Identifier mask register 5
 019E            CAN1IDM6 = REGBS+$19E ;CAN1 Identifier mask register 6
 019F            CAN1IDM7 = REGBS+$19F ;CAN1 Identifier mask register 7
 01A0            CAN1RXFG = REGBS+$1A0 ;CAN1 RX foregroundbuffer thru +$1AF
 01B0            CAN1TXFG = REGBS+$1B0 ;CAN1 TX foregroundbuffer thru +$1BF
 4248            
 01C0            CAN2CTL0 = REGBS+$1C0 ;CAN2 control register 0
 01C1            CAN2CTL1 = REGBS+$1C1 ;CAN2 control register 1
 01C2            CAN2BTR0 = REGBS+$1C2 ;CAN2 bus timing register 0
 01C3            CAN2BTR1 = REGBS+$1C3 ;CAN2 bus timing register 1
 01C4            CAN2RFLG = REGBS+$1C4 ;CAN2 receiver flags
 01C5            CAN2RIER = REGBS+$1C5 ;CAN2 receiver interrupt enables
 01C6            CAN2TFLG = REGBS+$1C6 ;CAN2 transmit flags
 01C7            CAN2TIER = REGBS+$1C7 ;CAN2 transmit interrupt enables
 01C8            CAN2TARQ = REGBS+$1C8 ;CAN2 transmit message abort control
 01C9            CAN2TAAK = REGBS+$1C9 ;CAN2 transmit message abort status
 01CA            CAN2TBEL = REGBS+$1CA ;CAN2 transmit buffer select
 01CB            CAN2IDAC = REGBS+$1CB ;CAN2 identfier acceptancecontrol
 4248            
 01CE            CAN2RERR = REGBS+$1CE ;CAN2 Receive error counter
 01CF            CAN2TERR = REGBS+$1CF ;CAN2 Transmit error counter
 01D0            CAN2IDA0 = REGBS+$1D0 ;CAN2 Identifier acceptanceregister 0
 01D1            CAN2IDA1 = REGBS+$1D1 ;CAN2 Identifier acceptanceregister 1
 01D2            CAN2IDA2 = REGBS+$1D2 ;CAN2 Identifier acceptanceregister 2
 01D3            CAN2IDA3 = REGBS+$1D3 ;CAN2 Identifier acceptanceregister 3
 01D4            CAN2IDM0 = REGBS+$1D4 ;CAN2 Identifier mask register 0
 01D5            CAN2IDM1 = REGBS+$1D5 ;CAN2 Identifier mask register 1
 01D6            CAN2IDM2 = REGBS+$1D6 ;CAN2 Identifier mask register 2
 01D7            CAN2IDM3 = REGBS+$1D7 ;CAN2 Identifier mask register 3
 01D8            CAN2IDA4 = REGBS+$1D8 ;CAN2 Identifier acceptanceregister 4
 01D9            CAN2IDA5 = REGBS+$1D9 ;CAN2 Identifier acceptanceregister 5
 01DA            CAN2IDA6 = REGBS+$1DA ;CAN2 Identifier acceptanceregister 6
 01DB            CAN2IDA7 = REGBS+$1DB ;CAN2 Identifier acceptanceregister 7
 01DC            CAN2IDM4 = REGBS+$1DC ;CAN2 Identifier mask register 4
 01DD            CAN2IDM5 = REGBS+$1DD ;CAN2 Identifier mask register 5
 01DE            CAN2IDM6 = REGBS+$1DE ;CAN2 Identifier mask register 6
 01DF            CAN2IDM7 = REGBS+$1DF ;CAN2 Identifier mask register 7
 01E0            CAN2RXFG = REGBS+$1E0 ;CAN2 RX foregroundbuffer thru +$1EF
 01F0            CAN2TXFG = REGBS+$1F0 ;CAN2 TX foregroundbuffer thru +$1FF
 4248            
 0200            CAN3CTL0 = REGBS+$200 ;CAN3 control register 0
 0201            CAN3CTL1 = REGBS+$201 ;CAN3 control register 1
 0202            CAN3BTR0 = REGBS+$202 ;CAN3 bus timing register 0
 0203            CAN3BTR1 = REGBS+$203 ;CAN3 bus timing register 1
 0204            CAN3RFLG = REGBS+$204 ;CAN3 receiver flags
 0205            CAN3RIER = REGBS+$205 ;CAN3 receiver interrupt enables
 0206            CAN3TFLG = REGBS+$206 ;CAN3 transmit flags
 0207            CAN3TIER = REGBS+$207 ;CAN3 transmit interrupt enables
 0208            CAN3TARQ = REGBS+$208 ;CAN3 transmit message abort control
 0209            CAN3TAAK = REGBS+$209 ;CAN3 transmit message abort status
 020A            CAN3TBEL = REGBS+$20A ;CAN3 transmit buffer select
 020B            CAN3IDAC = REGBS+$20B ;CAN3 identfier acceptancecontrol
 4248            
 020E            CAN3RERR = REGBS+$20E ;CAN3 Receive error counter
 020F            CAN3TERR = REGBS+$20F ;CAN3 Transmit error counter
 0210            CAN3IDA0 = REGBS+$210 ;CAN3 Identifier acceptanceregister 0
 0211            CAN3IDA1 = REGBS+$211 ;CAN3 Identifier acceptanceregister 1
 0212            CAN3IDA2 = REGBS+$212 ;CAN3 Identifier acceptanceregister 2
 0213            CAN3IDA3 = REGBS+$213 ;CAN3 Identifier acceptanceregister 3
 0214            CAN3IDM0 = REGBS+$214 ;CAN3 Identifier mask register 0
 0215            CAN3IDM1 = REGBS+$215 ;CAN3 Identifier mask register 1
 0216            CAN3IDM2 = REGBS+$216 ;CAN3 Identifier mask register 2
 0217            CAN3IDM3 = REGBS+$217 ;CAN3 Identifier mask register 3
 0218            CAN3IDA4 = REGBS+$218 ;CAN3 Identifier acceptanceregister 4
 0219            CAN3IDA5 = REGBS+$219 ;CAN3 Identifier acceptanceregister 5
 021A            CAN3IDA6 = REGBS+$21A ;CAN3 Identifier acceptanceregister 6
 021B            CAN3IDA7 = REGBS+$21B ;CAN3 Identifier acceptanceregister 7
 021C            CAN3IDM4 = REGBS+$21C ;CAN3 Identifier mask register 4
 021D            CAN3IDM5 = REGBS+$21D ;CAN3 Identifier mask register 5
 021E            CAN3IDM6 = REGBS+$21E ;CAN3 Identifier mask register 6
 021F            CAN3IDM7 = REGBS+$21F ;CAN3 Identifier mask register 7
 0220            CAN3RXFG = REGBS+$220 ;CAN3 RX foregroundbuffer thru +$22F
 0230            CAN3TXFG = REGBS+$230 ;CAN3 TX foregroundbuffer thru +$23F
 4248            
 0240            PTT = REGBS+$240 ;portT data register
 0241            PTIT = REGBS+$241 ;portT input register
 0242            DDRT = REGBS+$242 ;portT direction register
 0243            RDRT = REGBS+$243 ;portT reduced drive register
 0244            PERT = REGBS+$244 ;portT pull device enable
 0245            PPST = REGBS+$245 ;portT pull polarity select
 4248            
 0248            PTS = REGBS+$248 ;portS data register
 0249            PTIS = REGBS+$249 ;portS input register
 024A            DDRS = REGBS+$24A ;portS direction register
 024B            RDRS = REGBS+$24B ;portS reduced drive register
 024C            PERS = REGBS+$24C ;portS pull device enable
 024D            PPSS = REGBS+$24D ;portS pull polarity select
 024E            WOMS = REGBS+$24E ;portS Wired Or mode register
 4248            
 0250            PTM = REGBS+$250 ;portM data register
 0251            PTIM = REGBS+$251 ;portM input register
 0252            DDRM = REGBS+$252 ;portM direction register
 0253            RDRM = REGBS+$253 ;portM reduced drive register
 0254            PERM = REGBS+$254 ;portM pull device enable
 0255            PPSM = REGBS+$255 ;portM pull polarity select
 0256            WOMM = REGBS+$256 ;portM Wired Or mode register
 0257            MODRR = REGBS+$257 ;portM Module routing register
 0258            PTP = REGBS+$258 ;portP data register
 0259            PTIP = REGBS+$259 ;portP input register
 025A            DDRP = REGBS+$25A ;portP direction register
 025B            RDRP = REGBS+$25B ;portP reduced drive register
 025C            PERP = REGBS+$25C ;portP pull device enable
 025D            PPSP = REGBS+$25D ;portP pull polarity select
 025E            PIEP = REGBS+$25E ;portP interrupt enable register
 025F            PIFP = REGBS+$25F ;portP interrupt flag register
 0260            PTH = REGBS+$260 ;portH data register
 0261            PTIH = REGBS+$261 ;portH input register
 0262            DDRH = REGBS+$262 ;portH direction register
 0263            RDRH = REGBS+$263 ;portH reduced drive register
 0264            PERH = REGBS+$264 ;portH pull device enable
 0265            PPSH = REGBS+$265 ;portH pull polarity select
 0266            PIEH = REGBS+$266 ;portH interrupt enable register
 0267            PIFH = REGBS+$267 ;portH interrupt flag register
 0268            PTJ = REGBS+$268 ;portP data register
 0269            PTIJ = REGBS+$269 ;portP input register
 026A            DDRJ = REGBS+$26A ;portP direction register
 026B            RDRJ = REGBS+$26B ;portP reduced drive register
 026C            PERJ = REGBS+$26C ;portP pull device enable
 026D            PPSJ = REGBS+$26D ;portP pull polarity select
 026E            PIEJ = REGBS+$26E ;portP interrupt enable register
 026F            PIFJ = REGBS+$26F ;portP interrupt flag register
 4248            
 0280            CAN4CTL0 = REGBS+$280 ;CAN4 control register 0
 0281            CAN4CTL1 = REGBS+$281 ;CAN4 control register 1
 0282            CAN4BTR0 = REGBS+$282 ;CAN4 bus timing register 0
 0283            CAN4BTR1 = REGBS+$283 ;CAN4 bus timing register 1
 0284            CAN4RFLG = REGBS+$284 ;CAN4 receiver flags
 0285            CAN4RIER = REGBS+$285 ;CAN4 receiver interrupt enables
 0286            CAN4TFLG = REGBS+$286 ;CAN4 transmit flags
 0287            CAN4TIER = REGBS+$287 ;CAN4 transmit interrupt enables
 0288            CAN4TARQ = REGBS+$288 ;CAN4 transmit message abort control
 0289            CAN4TAAK = REGBS+$289 ;CAN4 transmit message abort status
 028A            CAN4TBEL = REGBS+$28A ;CAN4 transmit buffer select
 028B            CAN4IDAC = REGBS+$28B ;CAN4 identfier acceptancecontrol
 4248            
 028E            CAN4RERR = REGBS+$28E ;CAN4 Receive error counter
 028F            CAN4TERR = REGBS+$28F ;CAN4 Transmit error counter
 0290            CAN4IDA0 = REGBS+$290 ;CAN4 Identifier acceptanceregister 0
 0291            CAN4IDA1 = REGBS+$291 ;CAN4 Identifier acceptanceregister 1
 0292            CAN4IDA2 = REGBS+$292 ;CAN4 Identifier acceptanceregister 2
 0293            CAN4IDA3 = REGBS+$293 ;CAN4 Identifier acceptanceregister 3
 0294            CAN4IDM0 = REGBS+$294 ;CAN4 Identifier mask register 0
 0295            CAN4IDM1 = REGBS+$295 ;CAN4 Identifier mask register 1
 0296            CAN4IDM2 = REGBS+$296 ;CAN4 Identifier mask register 2
 0297            CAN4IDM3 = REGBS+$297 ;CAN4 Identifier mask register 3
 0298            CAN4IDA4 = REGBS+$298 ;CAN4 Identifier acceptanceregister 4
 0299            CAN4IDA5 = REGBS+$299 ;CAN4 Identifier acceptanceregister 5
 029A            CAN4IDA6 = REGBS+$29A ;CAN4 Identifier acceptanceregister 6
 029B            CAN4IDA7 = REGBS+$29B ;CAN4 Identifier acceptanceregister 7
 029C            CAN4IDM4 = REGBS+$29C ;CAN4 Identifier mask register 4
 029D            CAN4IDM5 = REGBS+$29D ;CAN4 Identifier mask register 5
 029E            CAN4IDM6 = REGBS+$29E ;CAN4 Identifier mask register 6
 029F            CAN4IDM7 = REGBS+$29F ;CAN4 Identifier mask register 7
 02A0            CAN4RXFG = REGBS+$2A0 ;CAN4 RX foregroundbuffer thru +$2AF
 02B0            CAN4TXFG = REGBS+$2B0 ;CAN4 TX foregroundbuffer thru +$2BF
 4248            
 4248            ; ========================================================
 4248            ;	basicLCD	Include file with minimal support 
 4248            ;			for LCD
 4248            ;	Requires : dp256reg.asm
 4248            ;
 4248            ;	Hacked from Lcd_2PP.asm:     L  Parallel Lcd Driver 
 4248            ;         Version:       1.0   Released 11/01/2002
 4248            ;          Author:       Gary Karnes , Axiom Manufacturing
 4248            ;        Compiler:       Asm12
 4248            ;        Platform:       CML12S & PROJECT BOARD 
 4248            ;
 4248            ; ========================================================
 4248            ;
 4248            ; Equates
 0001           U21_N = $01           ; LCD unused pin
 0002           LCD_RW = $02          ; LCD RW select (PT1)
 0004           LCD_RS = $04          ; LCD RS select	(PT2)
 0008           LCD_EN = $08          ; LCD EN select	(PT3)
 0080           U21_EN = $80
 4248            
 4248            _LCD_instruction::
 4248  3B                 pshd
 4249  34                 pshx
 424A  35                 pshy
 424B  180F               tba
 424D  1642C2             jsr LD2PP_Instruction
 4250  31                 puly
 4251  30                 pulx
 4252  3A                 puld
 4253  3D                 rts
 4254            _LCD_display::
 4254  3B                 pshd
 4255  34                 pshx
 4256  35                 pshy
 4257  180F               tba
 4259  1642BA             jsr LCD2PP_Data
 425C  31                 puly
 425D  30                 pulx
 425E  3A                 puld
 425F  3D                 rts
 4260                     
 4260            ;-----------
 4260            _Lcd2PP_Init::
 4260  3B                 pshd
 4261  34                 pshx
 4262  35                 pshy
 4263  16426A             jsr Lcd2PP_Init
 4266  31                 puly
 4267  30                 pulx
 4268  3A                 puld
 4269  3D                 rts    
 426A                      
 426A            Lcd2PP_Init:	; Note : Use 4-bit init sequence (not 8-bit)  Page 3 LCD_spec.pdf
 426A            		; Bottom table contains sequence of instructions
 426A            		; Each row in the table represents one WRITE to the LCD instruction register (via Port P)
 426A            		;	First instruction involves only a 4-bit instruction (one WRITE)
 426A            		;	Following instructions involve 8 bit instruction, therefore
 426A            		;		2 * 4-bit writes
 426A            
 426A            	; "System init"
 426A            	; Setup Port T for output
 426A  180B0F0242           movb #$0F,DDRT        ; setup port T
 426F  180B000240           movb #$00,PTT         ; all low
 4274                    ; Disable SPI AND setup SPI1 as four output bits
 4274  1C025A0F                bset  DDRP,#$0F           ; set P0-3 as outputs
 4278  1D00F040            bclr  SPI1CR1,#$40    ; Disable SP by turning SPI1 off
 427C            
 427C  180BFE0252           movb #$FE,DDRM        ; set PM1-7 as outputs
 4281  180B000250           movb #$00,PTM         ; D.P.(PM2) = Off, U7_EN(PM3)= low,
 4286                                            ; SS0*(PM4), SS1*(PM5), SS2*(PM6) = Low
 4286                                            ; Heat(PM7) = Off
 4286            
 4286  1D02400E            bclr    PTT,LCD_RW+LCD_RS+LCD_EN  ; select lcd commands Cs=0 En=0
 428A            
 428A  164308              jsr      DELAY50M
 428D  8602                ldaa     #$02         ; Set to 4-bit operation (0010)
 428F  1642CE              jsr      LCD2PP_4     ; This first instruction is only 4 bits long!!!  Rest are 8 bits.  
 4292  164308              jsr      DELAY50M
 4295            
 4295                    ;  ldaa     #$2c                ; Function Set = 001(D/L)NF** where D/L = 0(4-bit) N=1(2-lines) F=0(font=5x7 dots)
 4295  8628                ldaa     #$28         ; Function Set = 001(D/L)NF** where D/L = 0(4-bit) N=1(2-lines) F=0(font=5x7 dots)
 4297  1642C2              jsr      LD2PP_Instruction         
 429A  164316              jsr      DELAY10M         
 429D            
 429D  860E                ldaa      #$0e        ; Display On/off Control = 00001DCB where D=1(display on) C=1(cursor on) B=0 (blink off)
 429F  1642C2              jsr      LD2PP_Instruction          
 42A2  164316              jsr      DELAY10M          
 42A5                            
 42A5  8601                ldaa     #$01         ; Clear display = 00000001
 42A7  1642C2              jsr      LD2PP_Instruction           
 42AA  164311              jsr      DELAY20M          
 42AD  8680                ldaa     #$80         ; DDRAM Address Set = 01xxxxxx where xxxxxx = address
 42AF  1642C2              jsr      LD2PP_Instruction
 42B2  164316              jsr      DELAY10M        
 42B5            
 42B5            ; Reset Lcd states to rest
 42B5  1D02400E           bclr    PTT,LCD_RS+LCD_RW+LCD_EN ; turn all signals off on lcd
 42B9  3D                  rts
 42BA            ;
 42BA            ;-----------------------------------------------
 42BA            ; Lcd Routines
 42BA            ;
 42BA            ; Write a byte to the LCD Data Register
 42BA            LCD2PP_Data:
 42BA  1C024004        bset  PTT,LCD_RS     ; select lcd data buffer RS=1
 42BE  1642FB          jsr   LCD_W_8        ; write byte
 42C1  3D              rts
 42C2            
 42C2            ; Write a byte to the LCD Instruction Register (leaves LCD in Data mode)
 42C2            LD2PP_Instruction:
 42C2  1D024004          bclr   PTT,LCD_RS        ; select lcd command buffer
 42C6  1642FB            jsr    LCD_W_8           ; wait
 42C9  1C024004          bset   PTT,LCD_RS        ; select data buffer
 42CD  3D                rts
 42CE            
 42CE            LCD2PP_4:			; Destroys a and b
 42CE  1C024880           bset   PTS,#U21_EN     ; set U21_EN high so that latch becomes transparent
 42D2  16431F             jsr      DELAY1MS      ; delay     
 42D5  F60258             ldab     PTP              ; Port P
 42D8  C4F0               andb     #$f0             ; get only bits 4 - 7
 42DA  840F               anda     #$0f             ; get data
 42DC  1806               aba
 42DE  7A0258             staa     PTP              ; save data 
 42E1                    //For ;LCD's write cycle, Enable must pulse high and then low (for specified time)
 42E1  1D024008           bclr     PTT,LCD_EN       ; enable low
 42E5  16431F             jsr      DELAY1MS         ; delay for LCD
 42E8  1C024008           bset     PTT,LCD_EN       ; latch data
 42EC  16431F             jsr      DELAY1MS         ; delay for LCD 
 42EF  1D024008           bclr     PTT,LCD_EN           ; enable low
 42F3  16431F             jsr      DELAY1MS
 42F6  1D024880           bclr  PTS,#U21_EN    ; set U21_EN low to isolate LCD from parallel control (outputs are latched)
 42FA  3D                 rts
 42FB            ;
 42FB            ;
 42FB            ; Lcd Write 8 bit Data , lower 4 bits first in acc A   (Destroys A)
 42FB            LCD_W_8:					
 42FB  36                 psha                     ; save a 
 42FC  44                 lsra                     ; shift upper 4 bits to lower
 42FD  44                 lsra
 42FE  44                 lsra
 42FF  44                 lsra
 4300  1642CE             jsr      LCD2PP_4        ; write upper 4 bits to lcd
 4303  32                 pula
 4304  1642CE             jsr      LCD2PP_4         ; write lower 4 bits to lcd
 4307  3D                 rts
 4308                                                    
 4308            
 4308            ;
 4308            ; Delay routines
 4308            ;
 4308            ;
 4308            ; Generate a 50 ms delay
 4308            DELAY50M:
 4308  34                  pshx
 4309  CEC34E              ldx  #49998      ; delay 50,000 usecs,
 430C  164328              jsr  DELML01     ; call usec delay
 430F  30                  pulx
 4310  3D                  rts
 4311            ;
 4311            ;
 4311            ; Generate a 20 ms delay
 4311            DELAY20M:
 4311  0703                bsr  DELAY10M
 4313  0701                bsr  DELAY10M 
 4315  3D                  rts
 4316            ;
 4316            ; Generate a 10 ms delay
 4316            DELAY10M:                            ; jsr=4cyles
 4316  34                  pshx             ; 2 cycles ,save x
 4317  CE270E              ldx  #9998       ; 2 cycles,delay 9998 usec + 2 for this routine
 431A  164328              jsr  DELML01     ; call usec delay, this delay offset in sub
 431D  30                  pulx             ; 3 cycles restore x
 431E  3D                  rts              ; 5 cycles
 431F            ;
 431F            ;
 431F            ; Generate a 1 ms delay
 431F            DELAY1MS:
 431F                                       ; jsr=4cyles
 431F  34                  pshx             ; 2 cycles ,save x
 4320  CE03E6              ldx  #998       ; 2 cycles,delay 9998 usec + 2 for this routine
 4323  164328              jsr  DELML01     ; call usec delay, this delay offset in sub
 4326  30                  pulx             ; 3 cycles restore x
 4327  3D                  rts              ; 5 cycles
 4328            
 4328            
 4328            ;
 4328            ; 8 cycles = 1 usec e = 8mhz
 4328            DELML01:
 4328  A7                  nop              ; 1 cycle
 4329  A7                  nop              ; 1 cycle
 432A  A7                  nop              ; 1 cycle
 432B  A7                  nop              ; 1 cycle
 432C  09                  dex              ; 1 cycle 
 432D  26F9                bne   DELML01    ; 3 cycles
 432F  3D                  rts              ; 5 cycles
 4330            
                        .area bss
--- 0000                   .dbfile Assign44.C
 1004            _key::
 1004                    .blkb 1
 1005                    .dbsym e key _key c
                        .area text
--- 0306                   .dbfile Assign44.C
--- 0306           L20:
--- 0306 4F62737461636C652064657465637465  .byte 'O,'b,'s,'t,'a,'c,'l,'e,32,'d,'e,'t,'e,'c,'t,'e
--- 0316 642E20526F626F7420747572696E6720  .byte 'd,46,32,'R,'o,'b,'o,'t,32,'t,'u,'r,'i,'n,'g,32
--- 0326 726967687420696E2074687265652073  .byte 'r,'i,'g,'h,'t,32,'i,'n,32,'t,'h,'r,'e,'e,32,'s
--- 0336 65636F6E647320284C6F6F6B20617420  .byte 'e,'c,'o,'n,'d,'s,32,40,'L,'o,'o,'k,32,'a,'t,32
--- 0346 73746570706572206D6F746F7229210A  .byte 's,'t,'e,'p,'p,'e,'r,32,'m,'o,'t,'o,'r,41,33,10
--- 0356 00                .byte 0
--- 0357           L14:
--- 0357 40A00000          .word 0x40a0,0x0
--- 035B           L13:
--- 035B 3F800000          .word 0x3f80,0x0
--- 035F           L9:
--- 035F 00000000          .word 0x0,0x0
