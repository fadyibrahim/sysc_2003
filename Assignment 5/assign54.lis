                        .module assign54.C
 0000            REGBS = $0000 ; DP256 register bank base address
 0000            PORTA = REGBS+0 ;port A = Address lines A8 A15
 0001            PORTB = REGBS+1 ;port B = Address lines A0 A7
 0002            DDRA = REGBS+2 ;port A direction register
 0003            DDRB = REGBS+3 ;port A direction register
 0008            PORTE = REGBS+8 ;port E = mode,IRQandcontrolsignals
 0009            DDRE = REGBS+9 ;port E direction register
 000A            PEAR = REGBS+$A ;port E assignments
 000B            MODE = REGBS+$B ;Mode register
 000C            PUCR = REGBS+$C ;port pull-up control register
 000D            RDRIV = REGBS+$D ;port reduced drive control register
 000E            EBICTL = REGBS+$E ;E stretch control
 0000           
 0010            INITRM = REGBS+$10 ;Ram location register
 0011            INITRG = REGBS+$11 ;Register location register
 0012            INITEE = REGBS+$12 ;EEprom location register
 0013            MISC = REGBS+$13 ;MiscellaneoMapping control
 0014            MTST0 = REGBS+$14 ; RESERVED
 0015            ITCR = REGBS+$15 ;Interrupt test control register
 0016            ITEST = REGBS+$16 ;Interrupt test register
 0017            MTST1 = REGBS+$17 ; Reserved
 0000           
 001A            PARTIDH = REGBS+$1A ;Part ID high
 001B            PARTIDL = REGBS+$1B ;Part ID low
 001C            MEMSIZ0 = REGBS+$1C ;memory size
 001D            MEMSIZ1 = REGBS+$1D ;memory size
 001E            INTCR = REGBS+$1E ;interrupt control register
 001F            HPRIO = REGBS+$1F ;high priority reg
 0000           
 0028            BKPCT0 = REGBS+$28 ;Break control register
 0029            BKPCT1 = REGBS+$29 ;Break control register
 002A            BKP0X = REGBS+$2A ; Break 0 index register
 002B            BKP0H = REGBS+$2B ; Break 0 pointer high
 002C            BRP0L = REGBS+$2C ; Break 0 pointer low
 002D            BKP1X = REGBS+$2D ; Break 1 index register
 002E            BKP1H = REGBS+$2E ; Break 1 pointer high
 002F            BRP1L = REGBS+$2F ; Break 1 pointer low
 0030            PPAGE = REGBS+$30 ;Program Page register
 0000           
 0032            PORTK = REGBS+$32 ;Port K data
 0033            DDRK = REGBS+$33 ;Port K direction
 0034            SYNR = REGBS+$34 ; Synthesizer / multiplier register
 0035            REFDV = REGBS+$35 ; Reference divider register
 0036            CTFLG = REGBS+$36 ; RESERVED
 0037            CRGFLG = REGBS+$37 ; PLL flags register
 0038            CRGINT = REGBS+$38 ; PLL interrupt register
 0039            CLKSEL = REGBS+$39 ; Clock select register
 003A            PLLCTL = REGBS+$3A ; PLL control register
 003B            RTICTL = REGBS+$3B ;Real time interrupt control
 003C            COPCTL = REGBS+$3C ;Watchdog control
 003D            FORBYP = REGBS+$3D ;
 003E            CTCTL = REGBS+$3E ;
 003F            ARMCOP = REGBS+$3F ;COP reset register
 0000           
 0040            TIOS = REGBS+$40 ;timer input/output select
 0041            CFORC = REGBS+$41 ;timer compare force
 0042            OC7M = REGBS+$42 ;timer output compare 7 mask
 0043            OC7D = REGBS+$43 ;timer output compare 7 data
 0044            TCNT = REGBS+$44 ;timer counter register hi
 0045            *TCNT = REGBS+$45 ;timer counter register lo
 0046            TSCR = REGBS+$46 ;timer system control register
 0047            TTOV = REGBS+$47 ;reserved
 0048            TCTL1 = REGBS+$48 ;timer control register 1
 0049            TCTL2 = REGBS+$49 ;timer control register 2
 004A            TCTL3 = REGBS+$4A ;timer control register 3
 004B            TCTL4 = REGBS+$4B ;timer control register 4
 004C            TMSK1 = REGBS+$4C ;timer interrupt mask 1
 004D            TMSK2 = REGBS+$4D ;timer interrupt mask 2
 004E            TFLG1 = REGBS+$4E ;timer flags 1
 004F            TFLG2 = REGBS+$4F ;timer flags 2
 0050            TC0 = REGBS+$50 ;timer capture/comparregister 0
 0051            *TC0 = REGBS+$51 ;
 0052            TC1 = REGBS+$52 ;timer capture/comparregister 1
 0053            *TC1 = REGBS+$53 ;
 0054            TC2 = REGBS+$54 ;timer capture/comparregister 2
 0055            *TC2 = REGBS+$55 ;
 0056            TC3 = REGBS+$56 ;timer capture/comparregister 3
 0057            *TC3 = REGBS+$57 ;
 0058            TC4 = REGBS+$58 ;timer capture/comparregister 4
 0059            *TC4 = REGBS+$59 ;
 005A            TC5 = REGBS+$5A ;timer capture/comparregister 5
 005B            *TC5 = REGBS+$5B ;
 005C            TC6 = REGBS+$5C ;timer capture/comparregister 6
 005D            *TC6 = REGBS+$5D ;
 005E            TC7 = REGBS+$5E ;timer capture/comparregister 7
 005F            *TC7 = REGBS+$5F ;
 0060            PACTL = REGBS+$60 ;pulse accumulator controls
 0061            PAFLG = REGBS+$61 ;pulse accumulator flags
 0062            PACN3 = REGBS+$62 ;pulse accumulator counter 3
 0063            PACN2 = REGBS+$63 ;pulse accumulator counter 2
 0064            PACN1 = REGBS+$64 ;pulse accumulator counter 1
 0065            PACN0 = REGBS+$65 ;pulse accumulator counter 0
 0066            MCCTL = REGBS+$66 ;Modulus down conunter control
 0067            MCFLG = REGBS+$67 ;down counter flags
 0068            ICPAR = REGBS+$68 ;Input pulse accumulatocontrol
 0069            DLYCT = REGBS+$69 ;Delay count to down counter
 006A            ICOVW = REGBS+$6A ;Input control overwrite register
 006B            ICSYS = REGBS+$6B ;Input control system control
 0000           
 006D            TIMTST = REGBS+$6D ;timer test register
 0000           
 0070            PBCTL = REGBS+$70 ; Pulse accumulatoB control
 0071            PBFLG = REGBS+$71 ; Pulse accumulatoB flags
 0072            PA3H = REGBS+$72 ; Pulse Accumulatoholding regist3
 0073            PA2H = REGBS+$73 ; Pulse Accumulatoholding regist2
 0074            PA1H = REGBS+$74 ; Pulse Accumulatoholding regist1
 0075            PA0H = REGBS+$75 ; Pulse Accumulatoholding regist0
 0076            MCCNT = REGBS+$76 ; Modulus down counter register
 0077            *MCCNTL = REGBS+$77 ; low byte
 0078            TCOH = REGBS+$78 ; Capture 0 holding register
 007A            TC1H = REGBS+$7A ; Capture 1 holding register
 007C            TC2H = REGBS+$7C ; Capture 2 holding register
 007E            TC3H = REGBS+$7E ; Capture 3 holding register
 0000           
 0080            ATD0CTL0 = REGBS+$80 ;ADC control 0 (reserved)
 0081            ATD0CTL1 = REGBS+$81 ;ADC control 1 (reserved)
 0082            ATD0CTL2 = REGBS+$82 ;ADC control 2
 0083            ATD0CTL3 = REGBS+$83 ;ADC control 3
 0084            ATD0CTL4 = REGBS+$84 ;ADC control 4
 0085            ATD0CTL5 = REGBS+$85 ;ADC control 5
 0086            ATD0STAT = REGBS+$86 ;ADC status register hi
 0087            *ATD0STAT = REGBS+$87 ;ADC status register lo
 0088            ATD0TEST = REGBS+$88 ;ADC test (reserved)
 0089            *ATD0TEST = REGBS+$89 ;
 0000           
 008D            ATD0DIEN = REGBS+$8D ;
 0000           
 008F            PORTAD = REGBS+$8F ;port ADC = input only
 0090            ADR00H = REGBS+$90 ;ADC result 0 register
 0092            ADR01H = REGBS+$92 ;ADC result 1 register
 0094            ADR02H = REGBS+$94 ;ADC result 2 register
 0096            ADR03H = REGBS+$96 ;ADC result 3 register
 0098            ADR04H = REGBS+$98 ;ADC result 4 register
 009A            ADR05H = REGBS+$9A ;ADC result 5 register
 009C            ADR06H = REGBS+$9C ;ADC result 6 register
 009E            ADR07H = REGBS+$9E ;ADC result 7 register
 0000           
 00A0            PWME = REGBS+$A0 ;PWM enable
 00A1            PWMPOL = REGBS+$A1 ;PWM polarity
 00A2            PWMCLK = REGBS+$A2 ;PWM clock select register
 00A3            PWMPRCLK = REGBS+$A3 ;PWM Prescale clock select register
 00A4            PWMCAE = REGBS+$A4 ;PWM center align select register
 00A5            PWMCTL = REGBS+$A5 ;PWM control register
 00A6            PWMTST = REGBS+$A6 ;reserved
 00A7            PWMPRSC = REGBS+$A7 ;reserved
 00A8            PWMSCLA = REGBS+$A8 ;PWM Scale A
 00A9            PWMSCLB = REGBS+$A9 ;PWM scale B
 00AA            PWMSCNTA = REGBS+$AA ;reserved
 00AB            PWMSCNTB = REGBS+$AB ;reserved
 00AC            PWMCNT0 = REGBS+$AC ;PWM channel 0 counter
 00AD            PWMCNT1 = REGBS+$AD ;PWM channel 1 counter
 00AE            PWMCNT2 = REGBS+$AE ;PWM channel 2 counter
 00AF            PWMCNT3 = REGBS+$AF ;PWM channel 3 counter
 00B0            PWMCNT4 = REGBS+$B0 ;PWM channel 4 counter
 00B1            PWMCNT5 = REGBS+$B1 ;PWM channel 5 counter
 00B2            PWMCNT6 = REGBS+$B2 ;PWM channel 6 counter
 00B3            PWMCNT7 = REGBS+$B3 ;PWM channel 7 counter
 00B4            PWMPER0 = REGBS+$B4 ;PWM channel 0 period
 00B5            PWMPER1 = REGBS+$B5 ;PWM channel 1 period
 00B6            PWMPER2 = REGBS+$B6 ;PWM channel 2 period
 00B7            PWMPER3 = REGBS+$B7 ;PWM channel 3 period
 00B8            PWMPER4 = REGBS+$B8 ;PWM channel 4 period
 00B9            PWMPER5 = REGBS+$B9 ;PWM channel 5 period
 00BA            PWMPER6 = REGBS+$BA ;PWM channel 6 period
 00BB            PWMPER7 = REGBS+$BB ;PWM channel 7 period
 00BC            PWMDTY0 = REGBS+$BC ;PWM channel 0 duty cycle
 00BD            PWMDTY1 = REGBS+$BD ;PWM channel 1 duty cycle
 00BE            PWMDTY2 = REGBS+$BE ;PWM channel 2 duty cycle
 00BF            PWMDTY3 = REGBS+$BF ;PWM channel 3 duty cycle
 00C0            PWMDTY4 = REGBS+$C0 ;PWM channel 0 duty cycle
 00C1            PWMDTY5 = REGBS+$C1 ;PWM channel 1 duty cycle
 00C2            PWMDTY6 = REGBS+$C2 ;PWM channel 2 duty cycle
 00C3            PWMDTY7 = REGBS+$C3 ;PWM channel 3 duty cycle
 00C4            PWMSDN = REGBS+$C4 ;PWM shutdown register
 0000           
 00C8            SC0BDH = REGBS+$C8 ;sci 0 baud reg hi byte
 00C9            SC0BDL = REGBS+$C9 ;sci 0 baud reg lo byte
 00CA            SC0CR1 = REGBS+$CA ;sci 0 control1 reg
 00CB            SC0CR2 = REGBS+$CB ;sci 0 control2 reg
 00CC            SC0SR1 = REGBS+$CC ;sci 0 status reg 1
 00CD            SC0SR2 = REGBS+$CD ;sci 0 status reg 2
 00CE            SC0DRH = REGBS+$CE ;sci 0 data reg hi
 00CF            SC0DRL = REGBS+$CF ;sci 0 data reg lo
 00D0            SC1BDH = REGBS+$D0 ;sci 1 baud reg hi byte
 00D1            SC1BDL = REGBS+$D1 ;sci 1 baud reg lo byte
 00D2            SC1CR1 = REGBS+$D2 ;sci 1 control1 reg
 00D3            SC1CR2 = REGBS+$D3 ;sci 1 control2 reg
 00D4            SC1SR1 = REGBS+$D4 ;sci 1 status reg 1
 00D5            SC1SR2 = REGBS+$D5 ;sci 1 status reg 2
 00D6            SC1DRH = REGBS+$D6 ;sci 1 data reg hi
 00D7            SC1DRL = REGBS+$D7 ;sci 1 data reg lo
 00D8            SPI0CR1 = REGBS+$D8 ;spi 0 control1 reg
 00D9            SPI0CR2 = REGBS+$D9 ;spi 0 control2 reg
 00DA            SPI0BR = REGBS+$DA ;spi 0 baud reg
 00DB            SPI0SR = REGBS+$DB ;spi 0 status reg hi
 0000           
 00DD            SP0DR = REGBS+$DD ;spi 0 data reg
 0000           
 00E0            IBAD = REGBS+$E0 ;I2C Bus address register
 00E1            IBFD = REGBS+$E1 ;I2C Bus fr=ency divider
 00E2            IBCR = REGBS+$E2 ;I2C Bus control register
 00E3            IBSR = REGBS+$E3 ;I2C Bus status register
 00E4            IBDR = REGBS+$E4 ;I2C Bus message data register
 0000           
 00E8            DLCBCR1 = REGBS+$E8 ;BDLC Control regsiter 1
 00E9            DLCBSVR = REGBS+$E9 ;BDLC State vector register
 00EA            DLCBCR2 = REGBS+$EA ;BDLC Control register 2
 00EB            DLCBDR = REGBS+$EB ;BDLC Data register
 00EC            DLCBARD = REGBS+$EC ;BDLC Analog delay register
 00ED            DLCBRSR = REGBS+$ED ;BDLC Rate select register
 00EE            DLCSCR = REGBS+$EE ;BDLC Control register
 00EF            DLCBSTAT = REGBS+$EF ;BDLC Status register
 00F0            SPI1CR1 = REGBS+$F0 ;spi 1 control1 reg
 00F1            SPI1CR2 = REGBS+$F1 ;spi 1 control2 reg
 00F2            SPI1BR = REGBS+$F2 ;spi 1 baud reg
 00F3            SPI1SR = REGBS+$F3 ;spi 1 status reg hi
 0000           
 00F5            SP1DR = REGBS+$F5 ;spi 1 data reg
 0000           
 00F8            SPI2CR1 = REGBS+$F8 ;spi 2 control1 reg
 00F9            SPI2CR2 = REGBS+$F9 ;spi 2 control2 reg
 00FA            SPI2BR = REGBS+$FA ;spi 2 baud reg
 00FB            SPI2SR = REGBS+$FB ;spi 2 status reg hi
 0000           
 00FD            SP2DR = REGBS+$FD ;spi 2 data reg
 0000           
 0100            FCLKDIV = REGBS+$100 ;FLASH clock divider
 0101            FSEC = REGBS+$101 ;FLASH security register
 0000           
 0103            FCNFG = REGBS+$103 ;FLASH configuration register
 0104            FPROT = REGBS+$104 ;FLASH protection register
 0105            FSTAT = REGBS+$105 ;FLASH status register
 0106            FCMD = REGBS+$106 ;FLASH command register
 0000           
 0110            ECLKDIV = REGBS+$110 ;EEPROM clock divider
 0000           
 0113            ECNFG = REGBS+$113 ;EEPROM configuration register
 0114            EPROT = REGBS+$114 ;EEPROM protection register
 0115            ESTAT = REGBS+$115 ;EEPROM status register
 0116            ECMD = REGBS+$116 ;EEPROM command register
 0000           
 0120            ATD1CTL0 = REGBS+$120 ;ADC1 control 0 (reserved)
 0121            ATD1CTL1 = REGBS+$121 ;ADC1 control 1 (reserved)
 0122            ATD1CTL2 = REGBS+$122 ;ADC1 control 2
 0123            ATD1CTL3 = REGBS+$123 ;ADC1 control 3
 0124            ATD1CTL4 = REGBS+$124 ;ADC1 control 4
 0125            ATD1CTL5 = REGBS+$125 ;ADC1 control 5
 0126            ATD1STAT = REGBS+$126 ;ADC1 status register hi
 0127            *ATD1STAT = REGBS+$127 ;ADC1 status register lo
 0128            ATD1TEST = REGBS+$128 ;ADC1 test (reserved)
 0129            *ATD1TEST = REGBS+$129 ;
 0000           
 012D            ATDDIEN = REGBS+$12D ;ADC1 INPUT ENABLE REGISTER
 0000           
 012F            PORTAD1 = REGBS+$12F ;port ADC1 = input only
 0130            ADR10H = REGBS+$130 ;ADC1 result 0 register
 0132            ADR11H = REGBS+$132 ;ADC1 result 1 register
 0134            ADR12H = REGBS+$134 ;ADC1 result 2 register
 0136            ADR13H = REGBS+$136 ;ADC1 result 3 register
 0138            ADR14H = REGBS+$138 ;ADC1 result 4 register
 013A            ADR15H = REGBS+$13A ;ADC1 result 5 register
 013C            ADR16H = REGBS+$13C ;ADC1 result 6 register
 013E            ADR17H = REGBS+$13E ;ADC1 result 7 register
 0140            CAN0CTL0 = REGBS+$140 ;CAN0 control register 0
 0141            CAN0CTL1 = REGBS+$141 ;CAN0 control register 1
 0142            CAN0BTR0 = REGBS+$142 ;CAN0 bus timing register 0
 0143            CAN0BTR1 = REGBS+$143 ;CAN0 bus timing register 1
 0144            CAN0RFLG = REGBS+$144 ;CAN0 receiver flags
 0145            CAN0RIER = REGBS+$145 ;CAN0 receiver interrupt enables
 0146            CAN0TFLG = REGBS+$146 ;CAN0 transmit flags
 0147            CAN0TIER = REGBS+$147 ;CAN0 transmit interrupt enables
 0148            CAN0TARQ = REGBS+$148 ;CAN0 transmit message abort control
 0149            CAN0TAAK = REGBS+$149 ;CAN0 transmit message abort status
 014A            CAN0TBEL = REGBS+$14A ;CAN0 transmit buffer select
 014B            CAN0IDAC = REGBS+$14B ;CAN0 identfier acceptancecontrol
 0000           
 014E            CAN0RERR = REGBS+$14E ;CAN0 Receive error counter
 014F            CAN0TERR = REGBS+$14F ;CAN0 Transmit error counter
 0150            CAN0IDA0 = REGBS+$150 ;CAN0 Identifier acceptanceregister 0
 0151            CAN0IDA1 = REGBS+$151 ;CAN0 Identifier acceptanceregister 1
 0152            CAN0IDA2 = REGBS+$152 ;CAN0 Identifier acceptanceregister 2
 0153            CAN0IDA3 = REGBS+$153 ;CAN0 Identifier acceptanceregister 3
 0154            CAN0IDM0 = REGBS+$154 ;CAN0 Identifier mask register 0
 0155            CAN0IDM1 = REGBS+$155 ;CAN0 Identifier mask register 1
 0156            CAN0IDM2 = REGBS+$156 ;CAN0 Identifier mask register 2
 0157            CAN0IDM3 = REGBS+$157 ;CAN0 Identifier mask register 3
 0158            CAN0IDA4 = REGBS+$158 ;CAN0 Identifier acceptanceregister 4
 0159            CAN0IDA5 = REGBS+$159 ;CAN0 Identifier acceptanceregister 5
 015A            CAN0IDA6 = REGBS+$15A ;CAN0 Identifier acceptanceregister 6
 015B            CAN0IDA7 = REGBS+$15B ;CAN0 Identifier acceptanceregister 7
 015C            CAN0IDM4 = REGBS+$15C ;CAN0 Identifier mask register 4
 015D            CAN0IDM5 = REGBS+$15D ;CAN0 Identifier mask register 5
 015E            CAN0IDM6 = REGBS+$15E ;CAN0 Identifier mask register 6
 015F            CAN0IDM7 = REGBS+$15F ;CAN0 Identifier mask register 7
 0160            CAN0RXFG = REGBS+$160 ;CAN0 RX foregroundbuffer thru +$16F
 0170            CAN0TXFG = REGBS+$170 ;CAN0 TX foregroundbuffer thru +$17F
 0000           
 0180            CAN1CTL0 = REGBS+$180 ;CAN1 control register 0
 0181            CAN1CTL1 = REGBS+$181 ;CAN1 control register 1
 0182            CAN1BTR0 = REGBS+$182 ;CAN1 bus timing register 0
 0183            CAN1BTR1 = REGBS+$183 ;CAN1 bus timing register 1
 0184            CAN1RFLG = REGBS+$184 ;CAN1 receiver flags
 0185            CAN1RIER = REGBS+$185 ;CAN1 receiver interrupt enables
 0186            CAN1TFLG = REGBS+$186 ;CAN1 transmit flags
 0187            CAN1TIER = REGBS+$187 ;CAN1 transmit interrupt enables
 0188            CAN1TARQ = REGBS+$188 ;CAN1 transmit message abort control
 0189            CAN1TAAK = REGBS+$189 ;CAN1 transmit message abort status
 018A            CAN1TBEL = REGBS+$18A ;CAN1 transmit buffer select
 018B            CAN1IDAC = REGBS+$18B ;CAN1 identfier acceptancecontrol
 0000           
 018E            CAN1RERR = REGBS+$18E ;CAN1 Receive error counter
 018F            CAN1TERR = REGBS+$18F ;CAN1 Transmit error counter
 0190            CAN1IDA0 = REGBS+$190 ;CAN1 Identifier acceptanceregister 0
 0191            CAN1IDA1 = REGBS+$191 ;CAN1 Identifier acceptanceregister 1
 0192            CAN1IDA2 = REGBS+$192 ;CAN1 Identifier acceptanceregister 2
 0193            CAN1IDA3 = REGBS+$193 ;CAN1 Identifier acceptanceregister 3
 0194            CAN1IDM0 = REGBS+$194 ;CAN1 Identifier mask register 0
 0195            CAN1IDM1 = REGBS+$195 ;CAN1 Identifier mask register 1
 0196            CAN1IDM2 = REGBS+$196 ;CAN1 Identifier mask register 2
 0197            CAN1IDM3 = REGBS+$197 ;CAN1 Identifier mask register 3
 0198            CAN1IDA4 = REGBS+$198 ;CAN1 Identifier acceptanceregister 4
 0199            CAN1IDA5 = REGBS+$199 ;CAN1 Identifier acceptanceregister 5
 019A            CAN1IDA6 = REGBS+$19A ;CAN1 Identifier acceptanceregister 6
 019B            CAN1IDA7 = REGBS+$19B ;CAN1 Identifier acceptanceregister 7
 019C            CAN1IDM4 = REGBS+$19C ;CAN1 Identifier mask register 4
 019D            CAN1IDM5 = REGBS+$19D ;CAN1 Identifier mask register 5
 019E            CAN1IDM6 = REGBS+$19E ;CAN1 Identifier mask register 6
 019F            CAN1IDM7 = REGBS+$19F ;CAN1 Identifier mask register 7
 01A0            CAN1RXFG = REGBS+$1A0 ;CAN1 RX foregroundbuffer thru +$1AF
 01B0            CAN1TXFG = REGBS+$1B0 ;CAN1 TX foregroundbuffer thru +$1BF
 0000           
 01C0            CAN2CTL0 = REGBS+$1C0 ;CAN2 control register 0
 01C1            CAN2CTL1 = REGBS+$1C1 ;CAN2 control register 1
 01C2            CAN2BTR0 = REGBS+$1C2 ;CAN2 bus timing register 0
 01C3            CAN2BTR1 = REGBS+$1C3 ;CAN2 bus timing register 1
 01C4            CAN2RFLG = REGBS+$1C4 ;CAN2 receiver flags
 01C5            CAN2RIER = REGBS+$1C5 ;CAN2 receiver interrupt enables
 01C6            CAN2TFLG = REGBS+$1C6 ;CAN2 transmit flags
 01C7            CAN2TIER = REGBS+$1C7 ;CAN2 transmit interrupt enables
 01C8            CAN2TARQ = REGBS+$1C8 ;CAN2 transmit message abort control
 01C9            CAN2TAAK = REGBS+$1C9 ;CAN2 transmit message abort status
 01CA            CAN2TBEL = REGBS+$1CA ;CAN2 transmit buffer select
 01CB            CAN2IDAC = REGBS+$1CB ;CAN2 identfier acceptancecontrol
 0000           
 01CE            CAN2RERR = REGBS+$1CE ;CAN2 Receive error counter
 01CF            CAN2TERR = REGBS+$1CF ;CAN2 Transmit error counter
 01D0            CAN2IDA0 = REGBS+$1D0 ;CAN2 Identifier acceptanceregister 0
 01D1            CAN2IDA1 = REGBS+$1D1 ;CAN2 Identifier acceptanceregister 1
 01D2            CAN2IDA2 = REGBS+$1D2 ;CAN2 Identifier acceptanceregister 2
 01D3            CAN2IDA3 = REGBS+$1D3 ;CAN2 Identifier acceptanceregister 3
 01D4            CAN2IDM0 = REGBS+$1D4 ;CAN2 Identifier mask register 0
 01D5            CAN2IDM1 = REGBS+$1D5 ;CAN2 Identifier mask register 1
 01D6            CAN2IDM2 = REGBS+$1D6 ;CAN2 Identifier mask register 2
 01D7            CAN2IDM3 = REGBS+$1D7 ;CAN2 Identifier mask register 3
 01D8            CAN2IDA4 = REGBS+$1D8 ;CAN2 Identifier acceptanceregister 4
 01D9            CAN2IDA5 = REGBS+$1D9 ;CAN2 Identifier acceptanceregister 5
 01DA            CAN2IDA6 = REGBS+$1DA ;CAN2 Identifier acceptanceregister 6
 01DB            CAN2IDA7 = REGBS+$1DB ;CAN2 Identifier acceptanceregister 7
 01DC            CAN2IDM4 = REGBS+$1DC ;CAN2 Identifier mask register 4
 01DD            CAN2IDM5 = REGBS+$1DD ;CAN2 Identifier mask register 5
 01DE            CAN2IDM6 = REGBS+$1DE ;CAN2 Identifier mask register 6
 01DF            CAN2IDM7 = REGBS+$1DF ;CAN2 Identifier mask register 7
 01E0            CAN2RXFG = REGBS+$1E0 ;CAN2 RX foregroundbuffer thru +$1EF
 01F0            CAN2TXFG = REGBS+$1F0 ;CAN2 TX foregroundbuffer thru +$1FF
 0000           
 0200            CAN3CTL0 = REGBS+$200 ;CAN3 control register 0
 0201            CAN3CTL1 = REGBS+$201 ;CAN3 control register 1
 0202            CAN3BTR0 = REGBS+$202 ;CAN3 bus timing register 0
 0203            CAN3BTR1 = REGBS+$203 ;CAN3 bus timing register 1
 0204            CAN3RFLG = REGBS+$204 ;CAN3 receiver flags
 0205            CAN3RIER = REGBS+$205 ;CAN3 receiver interrupt enables
 0206            CAN3TFLG = REGBS+$206 ;CAN3 transmit flags
 0207            CAN3TIER = REGBS+$207 ;CAN3 transmit interrupt enables
 0208            CAN3TARQ = REGBS+$208 ;CAN3 transmit message abort control
 0209            CAN3TAAK = REGBS+$209 ;CAN3 transmit message abort status
 020A            CAN3TBEL = REGBS+$20A ;CAN3 transmit buffer select
 020B            CAN3IDAC = REGBS+$20B ;CAN3 identfier acceptancecontrol
 0000           
 020E            CAN3RERR = REGBS+$20E ;CAN3 Receive error counter
 020F            CAN3TERR = REGBS+$20F ;CAN3 Transmit error counter
 0210            CAN3IDA0 = REGBS+$210 ;CAN3 Identifier acceptanceregister 0
 0211            CAN3IDA1 = REGBS+$211 ;CAN3 Identifier acceptanceregister 1
 0212            CAN3IDA2 = REGBS+$212 ;CAN3 Identifier acceptanceregister 2
 0213            CAN3IDA3 = REGBS+$213 ;CAN3 Identifier acceptanceregister 3
 0214            CAN3IDM0 = REGBS+$214 ;CAN3 Identifier mask register 0
 0215            CAN3IDM1 = REGBS+$215 ;CAN3 Identifier mask register 1
 0216            CAN3IDM2 = REGBS+$216 ;CAN3 Identifier mask register 2
 0217            CAN3IDM3 = REGBS+$217 ;CAN3 Identifier mask register 3
 0218            CAN3IDA4 = REGBS+$218 ;CAN3 Identifier acceptanceregister 4
 0219            CAN3IDA5 = REGBS+$219 ;CAN3 Identifier acceptanceregister 5
 021A            CAN3IDA6 = REGBS+$21A ;CAN3 Identifier acceptanceregister 6
 021B            CAN3IDA7 = REGBS+$21B ;CAN3 Identifier acceptanceregister 7
 021C            CAN3IDM4 = REGBS+$21C ;CAN3 Identifier mask register 4
 021D            CAN3IDM5 = REGBS+$21D ;CAN3 Identifier mask register 5
 021E            CAN3IDM6 = REGBS+$21E ;CAN3 Identifier mask register 6
 021F            CAN3IDM7 = REGBS+$21F ;CAN3 Identifier mask register 7
 0220            CAN3RXFG = REGBS+$220 ;CAN3 RX foregroundbuffer thru +$22F
 0230            CAN3TXFG = REGBS+$230 ;CAN3 TX foregroundbuffer thru +$23F
 0000           
 0240            PTT = REGBS+$240 ;portT data register
 0241            PTIT = REGBS+$241 ;portT input register
 0242            DDRT = REGBS+$242 ;portT direction register
 0243            RDRT = REGBS+$243 ;portT reduced drive register
 0244            PERT = REGBS+$244 ;portT pull device enable
 0245            PPST = REGBS+$245 ;portT pull polarity select
 0000           
 0248            PTS = REGBS+$248 ;portS data register
 0249            PTIS = REGBS+$249 ;portS input register
 024A            DDRS = REGBS+$24A ;portS direction register
 024B            RDRS = REGBS+$24B ;portS reduced drive register
 024C            PERS = REGBS+$24C ;portS pull device enable
 024D            PPSS = REGBS+$24D ;portS pull polarity select
 024E            WOMS = REGBS+$24E ;portS Wired Or mode register
 0000           
 0250            PTM = REGBS+$250 ;portM data register
 0251            PTIM = REGBS+$251 ;portM input register
 0252            DDRM = REGBS+$252 ;portM direction register
 0253            RDRM = REGBS+$253 ;portM reduced drive register
 0254            PERM = REGBS+$254 ;portM pull device enable
 0255            PPSM = REGBS+$255 ;portM pull polarity select
 0256            WOMM = REGBS+$256 ;portM Wired Or mode register
 0257            MODRR = REGBS+$257 ;portM Module routing register
 0258            PTP = REGBS+$258 ;portP data register
 0259            PTIP = REGBS+$259 ;portP input register
 025A            DDRP = REGBS+$25A ;portP direction register
 025B            RDRP = REGBS+$25B ;portP reduced drive register
 025C            PERP = REGBS+$25C ;portP pull device enable
 025D            PPSP = REGBS+$25D ;portP pull polarity select
 025E            PIEP = REGBS+$25E ;portP interrupt enable register
 025F            PIFP = REGBS+$25F ;portP interrupt flag register
 0260            PTH = REGBS+$260 ;portH data register
 0261            PTIH = REGBS+$261 ;portH input register
 0262            DDRH = REGBS+$262 ;portH direction register
 0263            RDRH = REGBS+$263 ;portH reduced drive register
 0264            PERH = REGBS+$264 ;portH pull device enable
 0265            PPSH = REGBS+$265 ;portH pull polarity select
 0266            PIEH = REGBS+$266 ;portH interrupt enable register
 0267            PIFH = REGBS+$267 ;portH interrupt flag register
 0268            PTJ = REGBS+$268 ;portP data register
 0269            PTIJ = REGBS+$269 ;portP input register
 026A            DDRJ = REGBS+$26A ;portP direction register
 026B            RDRJ = REGBS+$26B ;portP reduced drive register
 026C            PERJ = REGBS+$26C ;portP pull device enable
 026D            PPSJ = REGBS+$26D ;portP pull polarity select
 026E            PIEJ = REGBS+$26E ;portP interrupt enable register
 026F            PIFJ = REGBS+$26F ;portP interrupt flag register
 0000           
 0280            CAN4CTL0 = REGBS+$280 ;CAN4 control register 0
 0281            CAN4CTL1 = REGBS+$281 ;CAN4 control register 1
 0282            CAN4BTR0 = REGBS+$282 ;CAN4 bus timing register 0
 0283            CAN4BTR1 = REGBS+$283 ;CAN4 bus timing register 1
 0284            CAN4RFLG = REGBS+$284 ;CAN4 receiver flags
 0285            CAN4RIER = REGBS+$285 ;CAN4 receiver interrupt enables
 0286            CAN4TFLG = REGBS+$286 ;CAN4 transmit flags
 0287            CAN4TIER = REGBS+$287 ;CAN4 transmit interrupt enables
 0288            CAN4TARQ = REGBS+$288 ;CAN4 transmit message abort control
 0289            CAN4TAAK = REGBS+$289 ;CAN4 transmit message abort status
 028A            CAN4TBEL = REGBS+$28A ;CAN4 transmit buffer select
 028B            CAN4IDAC = REGBS+$28B ;CAN4 identfier acceptancecontrol
 0000           
 028E            CAN4RERR = REGBS+$28E ;CAN4 Receive error counter
 028F            CAN4TERR = REGBS+$28F ;CAN4 Transmit error counter
 0290            CAN4IDA0 = REGBS+$290 ;CAN4 Identifier acceptanceregister 0
 0291            CAN4IDA1 = REGBS+$291 ;CAN4 Identifier acceptanceregister 1
 0292            CAN4IDA2 = REGBS+$292 ;CAN4 Identifier acceptanceregister 2
 0293            CAN4IDA3 = REGBS+$293 ;CAN4 Identifier acceptanceregister 3
 0294            CAN4IDM0 = REGBS+$294 ;CAN4 Identifier mask register 0
 0295            CAN4IDM1 = REGBS+$295 ;CAN4 Identifier mask register 1
 0296            CAN4IDM2 = REGBS+$296 ;CAN4 Identifier mask register 2
 0297            CAN4IDM3 = REGBS+$297 ;CAN4 Identifier mask register 3
 0298            CAN4IDA4 = REGBS+$298 ;CAN4 Identifier acceptanceregister 4
 0299            CAN4IDA5 = REGBS+$299 ;CAN4 Identifier acceptanceregister 5
 029A            CAN4IDA6 = REGBS+$29A ;CAN4 Identifier acceptanceregister 6
 029B            CAN4IDA7 = REGBS+$29B ;CAN4 Identifier acceptanceregister 7
 029C            CAN4IDM4 = REGBS+$29C ;CAN4 Identifier mask register 4
 029D            CAN4IDM5 = REGBS+$29D ;CAN4 Identifier mask register 5
 029E            CAN4IDM6 = REGBS+$29E ;CAN4 Identifier mask register 6
 029F            CAN4IDM7 = REGBS+$29F ;CAN4 Identifier mask register 7
 02A0            CAN4RXFG = REGBS+$2A0 ;CAN4 RX foregroundbuffer thru +$2AF
 02B0            CAN4TXFG = REGBS+$2B0 ;CAN4 TX foregroundbuffer thru +$2BF
 0000           
 0000           ; ========================================================
 0000           ;	basicLCD	Include file with minimal support 
 0000           ;			for LCD
 0000           ;	Requires : dp256reg.asm
 0000           ;
 0000           ;	Hacked from Lcd_2PP.asm:     L  Parallel Lcd Driver 
 0000           ;         Version:       1.0   Released 11/01/2002
 0000           ;          Author:       Gary Karnes , Axiom Manufacturing
 0000           ;        Compiler:       Asm12
 0000           ;        Platform:       CML12S & PROJECT BOARD 
 0000           ;
 0000           ; ========================================================
 0000           ;
 0000           ; Equates
 0001           U21_N = $01           ; LCD unused pin
 0002           LCD_RW = $02          ; LCD RW select (PT1)
 0004           LCD_RS = $04          ; LCD RS select	(PT2)
 0008           LCD_EN = $08          ; LCD EN select	(PT3)
 0080           U21_EN = $80
 0000           
 0000           _LCD_instruction::
 0000 3B                 pshd
 0001 34                 pshx
 0002 35                 pshy
 0003 180F               tba
 0005 16007A             jsr LD2PP_Instruction
 0008 31                 puly
 0009 30                 pulx
 000A 3A                 puld
 000B 3D                 rts
 000C           _LCD_display::
 000C 3B                 pshd
 000D 34                 pshx
 000E 35                 pshy
 000F 180F               tba
 0011 160072             jsr LCD2PP_Data
 0014 31                 puly
 0015 30                 pulx
 0016 3A                 puld
 0017 3D                 rts
 0018                    
 0018           ;-----------
 0018           _Lcd2PP_Init::
 0018 3B                 pshd
 0019 34                 pshx
 001A 35                 pshy
 001B 160022             jsr Lcd2PP_Init
 001E 31                 puly
 001F 30                 pulx
 0020 3A                 puld
 0021 3D                 rts    
 0022                     
 0022           Lcd2PP_Init:	; Note : Use 4-bit init sequence (not 8-bit)  Page 3 LCD_spec.pdf
 0022           		; Bottom table contains sequence of instructions
 0022           		; Each row in the table represents one WRITE to the LCD instruction register (via Port P)
 0022           		;	First instruction involves only a 4-bit instruction (one WRITE)
 0022           		;	Following instructions involve 8 bit instruction, therefore
 0022           		;		2 * 4-bit writes
 0022           
 0022           	; "System init"
 0022           	; Setup Port T for output
 0022 180B0F0242           movb #$0F,DDRT        ; setup port T
 0027 180B000240           movb #$00,PTT         ; all low
 002C                   ; Disable SPI AND setup SPI1 as four output bits
 002C 1C025A0F                bset  DDRP,#$0F           ; set P0-3 as outputs
 0030 1D00F040            bclr  SPI1CR1,#$40    ; Disable SP by turning SPI1 off
 0034           
 0034 180BFE0252           movb #$FE,DDRM        ; set PM1-7 as outputs
 0039 180B080250           movb #$08,PTM         ; D.P.(PM2) = Off, U7_EN(PM3)= low,
 003E                                           ; SS0*(PM4), SS1*(PM5), SS2*(PM6) = Low
 003E                                           ; Heat(PM7) = Off
 003E           
 003E 1D02400E            bclr    PTT,LCD_RW+LCD_RS+LCD_EN  ; select lcd commands Cs=0 En=0
 0042           
 0042 1600C0              jsr      DELAY50M
 0045 8602                ldaa     #$02         ; Set to 4-bit operation (0010)
 0047 160086              jsr      LCD2PP_4     ; This first instruction is only 4 bits long!!!  Rest are 8 bits.  
 004A 1600C0              jsr      DELAY50M
 004D           
 004D                   ;  ldaa     #$2c                ; Function Set = 001(D/L)NF** where D/L = 0(4-bit) N=1(2-lines) F=0(font=5x7 dots)
 004D 8628                ldaa     #$28         ; Function Set = 001(D/L)NF** where D/L = 0(4-bit) N=1(2-lines) F=0(font=5x7 dots)
 004F 16007A              jsr      LD2PP_Instruction         
 0052 1600CE              jsr      DELAY10M         
 0055           
 0055 860E                ldaa      #$0e        ; Display On/off Control = 00001DCB where D=1(display on) C=1(cursor on) B=0 (blink off)
 0057 16007A              jsr      LD2PP_Instruction          
 005A 1600CE              jsr      DELAY10M          
 005D                           
 005D 8601                ldaa     #$01         ; Clear display = 00000001
 005F 16007A              jsr      LD2PP_Instruction           
 0062 1600C9              jsr      DELAY20M          
 0065 8680                ldaa     #$80         ; DDRAM Address Set = 01xxxxxx where xxxxxx = address
 0067 16007A              jsr      LD2PP_Instruction
 006A 1600CE              jsr      DELAY10M        
 006D           
 006D           ; Reset Lcd states to rest
 006D 1D02400E           bclr    PTT,LCD_RS+LCD_RW+LCD_EN ; turn all signals off on lcd
 0071 3D                  rts
 0072           ;
 0072           ;-----------------------------------------------
 0072           ; Lcd Routines
 0072           ;
 0072           ; Write a byte to the LCD Data Register
 0072           LCD2PP_Data:
 0072 1C024004        bset  PTT,LCD_RS     ; select lcd data buffer RS=1
 0076 1600B3          jsr   LCD_W_8        ; write byte
 0079 3D              rts
 007A           
 007A           ; Write a byte to the LCD Instruction Register (leaves LCD in Data mode)
 007A           LD2PP_Instruction:
 007A 1D024004          bclr   PTT,LCD_RS        ; select lcd command buffer
 007E 1600B3            jsr    LCD_W_8           ; wait
 0081 1C024004          bset   PTT,LCD_RS        ; select data buffer
 0085 3D                rts
 0086           
 0086           LCD2PP_4:			; Destroys a and b
 0086 1C024880           bset   PTS,#U21_EN     ; set U21_EN high so that latch becomes transparent
 008A 1600D7             jsr      DELAY1MS      ; delay     
 008D F60258             ldab     PTP              ; Port P
 0090 C4F0               andb     #$f0             ; get only bits 4 - 7
 0092 840F               anda     #$0f             ; get data
 0094 1806               aba
 0096 7A0258             staa     PTP              ; save data 
 0099                   ; For LCD's write cycle, Enable must pulse high and then low (for specified time)
 0099 1D024008           bclr     PTT,LCD_EN       ; enable low
 009D 1600D7             jsr      DELAY1MS         ; delay for LCD
 00A0 1C024008           bset     PTT,LCD_EN       ; latch data
 00A4 1600D7             jsr      DELAY1MS         ; delay for LCD 
 00A7 1D024008           bclr     PTT,LCD_EN           ; enable low
 00AB 1600D7             jsr      DELAY1MS
 00AE 1D024880           bclr  PTS,#U21_EN    ; set U21_EN low to isolate LCD from parallel control (outputs are latched)
 00B2 3D                 rts
 00B3           ;
 00B3           ;
 00B3           ; Lcd Write 8 bit Data , lower 4 bits first in acc A   (Destroys A)
 00B3           LCD_W_8:					
 00B3 36                 psha                     ; save a 
 00B4 44                 lsra                     ; shift upper 4 bits to lower
 00B5 44                 lsra
 00B6 44                 lsra
 00B7 44                 lsra
 00B8 160086             jsr      LCD2PP_4        ; write upper 4 bits to lcd
 00BB 32                 pula
 00BC 160086             jsr      LCD2PP_4         ; write lower 4 bits to lcd
 00BF 3D                 rts
 00C0                                                   
 00C0           
 00C0           ;
 00C0           ; Delay routines
 00C0           ;
 00C0           ;
 00C0           ; Generate a 50 ms delay
 00C0           DELAY50M:
 00C0 34                  pshx
 00C1 CEC34E              ldx  #49998      ; delay 50,000 usecs,
 00C4 1600E0              jsr  DELML01     ; call usec delay
 00C7 30                  pulx
 00C8 3D                  rts
 00C9           ;
 00C9           ;
 00C9           ; Generate a 20 ms delay
 00C9           DELAY20M:
 00C9 0703                bsr  DELAY10M
 00CB 0701                bsr  DELAY10M 
 00CD 3D                  rts
 00CE           ;
 00CE           ; Generate a 10 ms delay
 00CE           DELAY10M:                            ; jsr=4cyles
 00CE 34                  pshx             ; 2 cycles ,save x
 00CF CE270E              ldx  #9998       ; 2 cycles,delay 9998 usec + 2 for this routine
 00D2 1600E0              jsr  DELML01     ; call usec delay, this delay offset in sub
 00D5 30                  pulx             ; 3 cycles restore x
 00D6 3D                  rts              ; 5 cycles
 00D7           ;
 00D7           ;
 00D7           ; Generate a 1 ms delay
 00D7           DELAY1MS:
 00D7                                      ; jsr=4cyles
 00D7 34                  pshx             ; 2 cycles ,save x
 00D8 CE03E6              ldx  #998       ; 2 cycles,delay 9998 usec + 2 for this routine
 00DB 1600E0              jsr  DELML01     ; call usec delay, this delay offset in sub
 00DE 30                  pulx             ; 3 cycles restore x
 00DF 3D                  rts              ; 5 cycles
 00E0           
 00E0           
 00E0           ;
 00E0           ; 8 cycles = 1 usec e = 8mhz
 00E0           DELML01:
 00E0 A7                  nop              ; 1 cycle
 00E1 A7                  nop              ; 1 cycle
 00E2 A7                  nop              ; 1 cycle
 00E3 A7                  nop              ; 1 cycle
 00E4 09                  dex              ; 1 cycle 
 00E5 26F9                bne   DELML01    ; 3 cycles
 00E7 3D                  rts              ; 5 cycles
 00E8           
                        .area data
 0000           _changingSpeed::
 0000                   .blkb 2
                        .area idata
 00E8 007B              .word 123
                        .area data
 0002                   .dbfile assign54.C
 0002                   .dbsym e changingSpeed _changingSpeed I
 0002           _changingTemp::
 0002                   .blkb 2
                        .area idata
 00EA 0017              .word 23
                        .area data
 0004                   .dbfile assign54.C
 0004                   .dbsym e changingTemp _changingTemp I
                        .area text
 0000                   .dbfile assign54.C
 0000                   .dbfunc e main _main fV
 0000           ;          ?temp -> -2,x
 0000           _main::
 0000 34                pshx
 0001 B775              tfr s,x
 0003 1B9C              leas -4,sp
 0005                   .dbline -1
 0005                   .dbline 14
 0005           ; /*
 0005           ; Authors Gavez Smith 100857991, Fady Ibrahim 100876906
 0005           ; */
 0005           ; #include "hcs12dp256.h"
 0005           ; #include"stdio.h"
 0005           ; asm(".include'basicLCD.s'");
 0005           ; #pragma interrupt_handler printKeysPressed()
 0005           ; void printKeysPressed();
 0005           ; void Inc_Dec_Speed(int speed, int temp );
 0005           ; void displaySpeed_Temp(int speed, int temp);
 0005           ; int changingSpeed=123;
 0005           ; int changingTemp=23;
 0005           ; 
 0005           ; void main(){
 0005                   .dbline 16
 0005           ; 
 0005           ;        Lcd2PP_Init();
 0005 160018            jsr _Lcd2PP_Init
 0008                   .dbline 17
 0008           ;        displaySpeed_Temp(++changingSpeed, changingTemp);
 0008 1801800002        movw _changingTemp,0,sp
 000D FC0000            ldd _changingSpeed
 0010 C30001            addd #1
 0013 6C1E              std -2,x
 0015 18051E0000        movw -2,x,_changingSpeed
 001A EC1E              ldd -2,x
 001C 1601F5            jsr _displaySpeed_Temp
 001F                   .dbline 18
 001F           ;        DDRP |= 0x0F; // bitset PP0-3 as outputs (rows) 
 001F 1C025A0F          bset 0x25a,#15
 0023                   .dbline 19
 0023           ;        DDRH &= 0x0F; // bitclear PH4..7 as inputs (columns)
 0023 1D0262F0          bclr 0x262,#0xf0
 0027                   .dbline 20
 0027           ;        PTP = 0x0F; // Set scan row(s)
 0027 C60F              ldab #15
 0029 7B0258            stab 0x258
 002C                   .dbline 21
 002C           ;        PIFH = 0xFF; // Clear previous interrupt flags
 002C C6FF              ldab #255
 002E 7B0267            stab 0x267
 0031                   .dbline 22
 0031           ;        PPSH = 0xF0; // Rising Edge
 0031 C6F0              ldab #240
 0033 7B0265            stab 0x265
 0036                   .dbline 23
 0036           ;        PERH = 0x00; // Disable pulldowns
 0036 790264            clr 0x264
 0039                   .dbline 24
 0039           ;        PIEH |= 0xF0; // Local enable on columns inputs
 0039 1C0266F0          bset 0x266,#240
 003D                   .dbline 26
 003D           ;        // enable the latch.
 003D           ;        PTM |= 0x08;
 003D 1C025008          bset 0x250,#8
 0041                   .dbline 29
 0041           ;        //
 0041           ;        
 0041           ;        asm("cli");
 0041 10EF                      cli
 0043           
 0043           L4:
 0043                   .dbline 31
 0043                   .dbline 31
 0043           L5:
 0043                   .dbline 31
 0043 20FE              bra L4
 0045           X0:
 0045                   .dbline 31
 0045           ;        
 0045           ;        while(1){};
 0045                   .dbline -2
 0045                   .dbline 33
 0045           ;        
 0045           ; }
 0045           L3:
 0045 B757              tfr x,s
 0047 30                pulx
 0048                   .dbline 0 ; func end
 0048 3D                rts
 0049                   .dbend
 0049                   .dbfunc e printKeysPressed _printKeysPressed fV
 0049           ;          ?temp -> -8,x
 0049           ;          ?temp -> -8,x
 0049           ;          ?temp -> -6,x
 0049           ;          count -> -4,x
 0049           ;              i -> -2,x
 0049           _printKeysPressed::
 0049 34                pshx
 004A B775              tfr s,x
 004C 1B96              leas -10,sp
 004E                   .dbline -1
 004E                   .dbline 41
 004E           ; 
 004E           ; 
 004E           ; 
 004E           ; /*
 004E           ; printKeysPressed gets the character pressed on the keyboard by pulling and then it prints out the value on the terminal.
 004E           ; 
 004E           ; */
 004E           ; void printKeysPressed(){   
 004E                   .dbline 43
 004E           ;       int i, count;
 004E           ;       asm("sei");
 004E 1410                      sei
 0050           
 0050                   .dbline 45
 0050           ; 
 0050           ;       for (count=1; count<=0x08; count<<=1)
 0050 CC0001            ldd #1
 0053 6C1C              std -4,x
 0055           L8:
 0055                   .dbline 46
 0055           ;       {
 0055                   .dbline 47
 0055           ;               PTH&=0x0F;
 0055 1D0260F0          bclr 0x260,#0xf0
 0059                   .dbline 48
 0059           ;               PTP = (PTP&0xF0) | count;
 0059                   ; vol
 0059 F60258            ldab 0x258
 005C 87                clra
 005D 8400              anda #0
 005F C4F0              andb #240
 0061 AA1C              ora -4,x
 0063 EA1D              orb -3,x
 0065 7B0258            stab 0x258
 0068                   .dbline 50
 0068 CC0000            ldd #0
 006B 6C1E              std -2,x
 006D           L12:
 006D                   .dbline 50
 006D           L13:
 006D                   .dbline 50
 006D           ;               
 006D           ;               for (i=0;i<1000;i++);
 006D EC1E              ldd -2,x
 006F C30001            addd #1
 0072 6C1E              std -2,x
 0074                   .dbline 50
 0074 EC1E              ldd -2,x
 0076 8C03E8            cpd #1000
 0079 2DF2              blt L12
 007B                   .dbline 51
 007B           ;               switch(PTH & 0xF0){
 007B                   ; vol
 007B F60260            ldab 0x260
 007E 87                clra
 007F 8400              anda #0
 0081 C4F0              andb #240
 0083 6C1A              std -6,x
 0085 8C0020            cpd #32
 0088 1827008A          lbeq L32
 008C EC1A              ldd -6,x
 008E 8C0020            cpd #32
 0091 2E0B              bgt L72
 0093           L71:
 0093 EC1A              ldd -6,x
 0095 8C0010            cpd #16
 0098 2723              beq L19
 009A 18200138          lbra L16
 009E           L72:
 009E EC1A              ldd -6,x
 00A0 8C0040            cpd #64
 00A3 182700B2          lbeq L45
 00A7 EC1A              ldd -6,x
 00A9 8C0040            cpd #64
 00AC 182D0126          lblt L16
 00B0           L73:
 00B0 EC1A              ldd -6,x
 00B2 8C0080            cpd #128
 00B5 182700D4          lbeq L58
 00B9 18200119          lbra L16
 00BD           X1:
 00BD                   .dbline 51
 00BD           L19:
 00BD                   .dbline 53
 00BD           ;                    case 0x10:
 00BD           ;                                 if(PTP & 0x01) printf("1");
 00BD 1F0258010A        brclr 0x258,#1,L20
 00C2                   .dbline 53
 00C2 CC03A9            ldd #L22
 00C5 160000            jsr _printf
 00C8 1820010A          lbra L17
 00CC           L20:
 00CC                   .dbline 54
 00CC           ;                                 else if(PTP & 0x02) printf("4");
 00CC 1F0258020A        brclr 0x258,#2,L23
 00D1                   .dbline 54
 00D1 CC03A7            ldd #L25
 00D4 160000            jsr _printf
 00D7 182000FB          lbra L17
 00DB           L23:
 00DB                   .dbline 55
 00DB           ;                                 else if(PTP & 0x04) printf("7");
 00DB 1F0258040A        brclr 0x258,#4,L26
 00E0                   .dbline 55
 00E0 CC03A5            ldd #L28
 00E3 160000            jsr _printf
 00E6 182000EC          lbra L17
 00EA           L26:
 00EA                   .dbline 56
 00EA           ;                                 else if(PTP & 0x08){ 
 00EA 1F02580802        brclr 0x258,#8,X2
 00EF 2004              bra X3
 00F1 182000E1  X2:     lbra L17
 00F5           X3:
 00F5                   .dbline 56
 00F5                   .dbline 57
 00F5           ;                                     printf("E");
 00F5 CC03A3            ldd #L31
 00F8 160000            jsr _printf
 00FB                   .dbline 58
 00FB           ;                                         displaySpeed_Temp(++changingSpeed, changingTemp);
 00FB 1801800002        movw _changingTemp,0,sp
 0100 FC0000            ldd _changingSpeed
 0103 C30001            addd #1
 0106 6C18              std -8,x
 0108 1805180000        movw -8,x,_changingSpeed
 010D EC18              ldd -8,x
 010F 1601F5            jsr _displaySpeed_Temp
 0112                   .dbline 59
 0112           ;                             }
 0112                   .dbline 60
 0112           ;                        break;
 0112 182000C0          lbra L17
 0116           L32:
 0116                   .dbline 63
 0116           ; 
 0116           ;                    case 0x20:
 0116           ;                             if(PTP & 0x01) printf("2");
 0116 1F0258010A        brclr 0x258,#1,L33
 011B                   .dbline 63
 011B CC03A1            ldd #L35
 011E 160000            jsr _printf
 0121 182000B1          lbra L17
 0125           L33:
 0125                   .dbline 64
 0125           ;                                 else if(PTP & 0x02) printf("5");
 0125 1F0258020A        brclr 0x258,#2,L36
 012A                   .dbline 64
 012A CC039F            ldd #L38
 012D 160000            jsr _printf
 0130 182000A2          lbra L17
 0134           L36:
 0134                   .dbline 65
 0134           ;                                 else if(PTP & 0x04) printf("8");
 0134 1F0258040A        brclr 0x258,#4,L39
 0139                   .dbline 65
 0139 CC039D            ldd #L41
 013C 160000            jsr _printf
 013F 18200093          lbra L17
 0143           L39:
 0143                   .dbline 66
 0143           ;                                 else if(PTP & 0x08){
 0143 1F02580802        brclr 0x258,#8,X4
 0148 2004              bra X5
 014A 18200088  X4:     lbra L17
 014E           X5:
 014E                   .dbline 66
 014E                   .dbline 67
 014E           ;                                     printf("0");
 014E CC039B            ldd #L44
 0151 160000            jsr _printf
 0154                   .dbline 68
 0154           ;                                         asm("swi");
 0154 3F                        swi
 0155           
 0155                   .dbline 69
 0155           ;                                 }
 0155                   .dbline 70
 0155           ;                        break;
 0155 1820007D          lbra L17
 0159           L45:
 0159                   .dbline 73
 0159           ;                    
 0159           ;                    case 0x40:
 0159           ;                             if(PTP & 0x01) printf("3");
 0159 1F02580108        brclr 0x258,#1,L46
 015E                   .dbline 73
 015E CC0399            ldd #L48
 0161 160000            jsr _printf
 0164 2070              bra L17
 0166           L46:
 0166                   .dbline 74
 0166           ;                                 else if(PTP & 0x02) printf("6");
 0166 1F02580208        brclr 0x258,#2,L49
 016B                   .dbline 74
 016B CC0397            ldd #L51
 016E 160000            jsr _printf
 0171 2063              bra L17
 0173           L49:
 0173                   .dbline 75
 0173           ;                                 else if(PTP & 0x04) printf("9");
 0173 1F02580408        brclr 0x258,#4,L52
 0178                   .dbline 75
 0178 CC0395            ldd #L54
 017B 160000            jsr _printf
 017E 2056              bra L17
 0180           L52:
 0180                   .dbline 76
 0180           ;                                 else if(PTP & 0x08) printf("F");
 0180 1F02580851        brclr 0x258,#8,L17
 0185                   .dbline 76
 0185 CC0393            ldd #L57
 0188 160000            jsr _printf
 018B                   .dbline 77
 018B           ;                    break;
 018B 2049              bra L17
 018D           L58:
 018D                   .dbline 80
 018D           ;                        
 018D           ;                    case 0x80:
 018D           ;                             if(PTP & 0x01) printf("A");
 018D 1F02580108        brclr 0x258,#1,L59
 0192                   .dbline 80
 0192 CC0391            ldd #L61
 0195 160000            jsr _printf
 0198 203C              bra L17
 019A           L59:
 019A                   .dbline 81
 019A           ;                                 else if(PTP & 0x02) printf("B");
 019A 1F02580208        brclr 0x258,#2,L62
 019F                   .dbline 81
 019F CC038F            ldd #L64
 01A2 160000            jsr _printf
 01A5 202F              bra L17
 01A7           L62:
 01A7                   .dbline 82
 01A7           ;                                 else if(PTP & 0x04) printf("C");
 01A7 1F02580408        brclr 0x258,#4,L65
 01AC                   .dbline 82
 01AC CC038D            ldd #L67
 01AF 160000            jsr _printf
 01B2 2022              bra L17
 01B4           L65:
 01B4                   .dbline 83
 01B4           ;                                 else if(PTP & 0x08){
 01B4 1F0258081D        brclr 0x258,#8,L17
 01B9                   .dbline 83
 01B9                   .dbline 84
 01B9           ;                                      printf("D");
 01B9 CC038B            ldd #L70
 01BC 160000            jsr _printf
 01BF                   .dbline 85
 01BF           ;                                          displaySpeed_Temp(--changingSpeed, changingTemp);
 01BF 1801800002        movw _changingTemp,0,sp
 01C4 FC0000            ldd _changingSpeed
 01C7 830001            subd #1
 01CA 6C18              std -8,x
 01CC 1805180000        movw -8,x,_changingSpeed
 01D1 EC18              ldd -8,x
 01D3 1601F5            jsr _displaySpeed_Temp
 01D6                   .dbline 86
 01D6           ;                                 }
 01D6                   .dbline 87
 01D6           ;                    break; 
 01D6           L16:
 01D6           L17:
 01D6                   .dbline 89
 01D6           L9:
 01D6                   .dbline 45
 01D6 EC1C              ldd -4,x
 01D8 59                lsld
 01D9 6C1C              std -4,x
 01DB                   .dbline 45
 01DB EC1C              ldd -4,x
 01DD 8C0008            cpd #8
 01E0 182FFE71          lble L8
 01E4                   .dbline 92
 01E4           ;               }
 01E4           ;        }
 01E4           ;               
 01E4           ;                                               
 01E4           ;       PTP = 0x0F;
 01E4 C60F              ldab #15
 01E6 7B0258            stab 0x258
 01E9                   .dbline 93
 01E9           ;       PIFH = PIFH; // Acknowledge (all) interrupts
 01E9                   ; vol
 01E9 F60267            ldab 0x267
 01EC 7B0267            stab 0x267
 01EF                   .dbline 94
 01EF           ;     asm("cli");
 01EF 10EF                      cli
 01F1           
 01F1                   .dbline -2
 01F1                   .dbline 95
 01F1           ; }
 01F1           L7:
 01F1 B757              tfr x,s
 01F3 30                pulx
 01F4                   .dbline 0 ; func end
 01F4 0B                rti
 01F5                   .dbsym l count -4 I
 01F5                   .dbsym l i -2 I
 01F5                   .dbend
 01F5                   .dbfunc e displaySpeed_Temp _displaySpeed_Temp fV
 01F5           ; arraycharstemp -> -22,x
 01F5           ;     arraychars -> -18,x
 01F5           ;    holderSpeed -> -10,x
 01F5           ;     holderTemp -> -8,x
 01F5           ;         number -> -6,x
 01F5           ;      remainder -> -4,x
 01F5           ;          index -> -2,x
 01F5           ;           temp -> 6,x
 01F5           ;          speed -> 2,x
 01F5           _displaySpeed_Temp::
 01F5 3B                pshd
 01F6 34                pshx
 01F7 B775              tfr s,x
 01F9 1BF1E8            leas -24,sp
 01FC                   .dbline -1
 01FC                   .dbline 100
 01FC           ; /*
 01FC           ; DisplaySpeed_Temp displays the speed and temp passed in to the lcd display.
 01FC           ; */
 01FC           ; 
 01FC           ; void displaySpeed_Temp(int speed, int temp){  
 01FC                   .dbline 102
 01FC           ;        int number;
 01FC           ;        int index=3;
 01FC CC0003            ldd #3
 01FF 6C1E              std -2,x
 0201                   .dbline 105
 0201           ;        int arraychars[4];
 0201           ;        int arraycharstemp[2];
 0201           ;        int remainder=0;
 0201 CC0000            ldd #0
 0204 6C1C              std -4,x
 0206                   .dbline 106
 0206           ;        int holderSpeed=speed;
 0206 ED02              ldy 2,x
 0208 6D16              sty -10,x
 020A                   .dbline 107
 020A           ;        int holderTemp=temp;
 020A 18020618          movw 6,x,-8,x
 020E                   .dbline 108
 020E           ;      LCD_instruction(1);
 020E CC0001            ldd #1
 0211 160000            jsr _LCD_instruction
 0214                   .dbline 109
 0214           ;        LCD_display('S');
 0214 CC0053            ldd #83
 0217 16000C            jsr _LCD_display
 021A                   .dbline 110
 021A           ;        LCD_display('P');
 021A CC0050            ldd #80
 021D 16000C            jsr _LCD_display
 0220                   .dbline 111
 0220           ;        LCD_display('E');
 0220 CC0045            ldd #69
 0223 16000C            jsr _LCD_display
 0226                   .dbline 112
 0226           ;        LCD_display('E');
 0226 CC0045            ldd #69
 0229 16000C            jsr _LCD_display
 022C                   .dbline 113
 022C           ;        LCD_display('D');
 022C CC0044            ldd #68
 022F 16000C            jsr _LCD_display
 0232 205A              bra L76
 0234           L75:
 0234                   .dbline 115
 0234           ;        while (index>=0)
 0234           ;        {
 0234                   .dbline 116
 0234           ;                  if(holderSpeed!=0)
 0234 EC16              ldd -10,x
 0236 273C              beq L78
 0238                   .dbline 117
 0238           ;        {
 0238                   .dbline 119
 0238           ; //takes the decimal value passed in and turns it into the decimal value representation in ASCII
 0238           ;        remainder=holderSpeed%10;
 0238 EC16              ldd -10,x
 023A CD000A            ldy #10
 023D B7D6              exg x,y
 023F 1815              idivs
 0241 B7D6              exg x,y
 0243 6C1C              std -4,x
 0245                   .dbline 120
 0245           ;        holderSpeed=holderSpeed/10;
 0245 EC16              ldd -10,x
 0247 CD000A            ldy #10
 024A B7D6              exg x,y
 024C 1815              idivs
 024E B7D6              exg x,y
 0250 6D16              sty -10,x
 0252                   .dbline 121
 0252           ;        remainder=remainder+0x30;
 0252 EC1C              ldd -4,x
 0254 C30030            addd #48
 0257 6C1C              std -4,x
 0259                   .dbline 122
 0259           ;        arraychars[index]=remainder;
 0259 19E1EE            leay -18,x
 025C 6DE1E8            sty -24,x
 025F EC1E              ldd -2,x
 0261 59                lsld
 0262 E3E1E8            addd -24,x
 0265 B7C6              xgdy
 0267 EC1C              ldd -4,x
 0269 6C40              std 0,y
 026B                   .dbline 123
 026B           ;        index=index-1;
 026B EC1E              ldd -2,x
 026D 830001            subd #1
 0270 6C1E              std -2,x
 0272                   .dbline 124
 0272           ;        }       
 0272 201A              bra L79
 0274           L78:
 0274                   .dbline 126
 0274           ;        else
 0274           ;        {
 0274                   .dbline 127
 0274           ;                       arraychars[index]=0x30;
 0274 19E1EE            leay -18,x
 0277 6DE1E8            sty -24,x
 027A EC1E              ldd -2,x
 027C 59                lsld
 027D E3E1E8            addd -24,x
 0280 B7C6              xgdy
 0282 CC0030            ldd #48
 0285 6C40              std 0,y
 0287                   .dbline 128
 0287           ;                       index=index-1;
 0287 EC1E              ldd -2,x
 0289 830001            subd #1
 028C 6C1E              std -2,x
 028E                   .dbline 129
 028E           ;        }
 028E           L79:
 028E                   .dbline 130
 028E           L76:
 028E                   .dbline 114
 028E EC1E              ldd -2,x
 0290 2CA2              bge L75
 0292                   .dbline 131
 0292           ;        }
 0292           ;        LCD_display(' ');
 0292 CC0020            ldd #32
 0295 16000C            jsr _LCD_display
 0298                   .dbline 132
 0298           ;        for(index=0;index<4;index++)
 0298 CC0000            ldd #0
 029B 6C1E              std -2,x
 029D           L80:
 029D                   .dbline 133
 029D                   .dbline 134
 029D 19E1EE            leay -18,x
 02A0 6DE1E8            sty -24,x
 02A3 EC1E              ldd -2,x
 02A5 59                lsld
 02A6 E3E1E8            addd -24,x
 02A9 B7C6              xgdy
 02AB ED40              ldy 0,y
 02AD 6D1A              sty -6,x
 02AF                   .dbline 135
 02AF EC1A              ldd -6,x
 02B1 16000C            jsr _LCD_display
 02B4                   .dbline 136
 02B4           L81:
 02B4                   .dbline 132
 02B4 EC1E              ldd -2,x
 02B6 C30001            addd #1
 02B9 6C1E              std -2,x
 02BB                   .dbline 132
 02BB EC1E              ldd -2,x
 02BD 8C0004            cpd #4
 02C0 2DDB              blt L80
 02C2                   .dbline 138
 02C2           ;        {
 02C2           ;               number=arraychars[index];
 02C2           ;               LCD_display(number);
 02C2           ;        }
 02C2           ;        
 02C2           ;        index=1;
 02C2 CC0001            ldd #1
 02C5 6C1E              std -2,x
 02C7                   .dbline 140
 02C7           ;        //goes to the next line.
 02C7           ;        LCD_instruction(0xC0); 
 02C7 CC00C0            ldd #192
 02CA 160000            jsr _LCD_instruction
 02CD                   .dbline 141
 02CD           ;        LCD_display('T');
 02CD CC0054            ldd #84
 02D0 16000C            jsr _LCD_display
 02D3                   .dbline 142
 02D3           ;        LCD_display('E');
 02D3 CC0045            ldd #69
 02D6 16000C            jsr _LCD_display
 02D9                   .dbline 143
 02D9           ;        LCD_display('M');
 02D9 CC004D            ldd #77
 02DC 16000C            jsr _LCD_display
 02DF                   .dbline 144
 02DF           ;        LCD_display('P');
 02DF CC0050            ldd #80
 02E2 16000C            jsr _LCD_display
 02E5                   .dbline 145
 02E5           ;        LCD_display('E');
 02E5 CC0045            ldd #69
 02E8 16000C            jsr _LCD_display
 02EB                   .dbline 146
 02EB           ;        LCD_display('R');
 02EB CC0052            ldd #82
 02EE 16000C            jsr _LCD_display
 02F1                   .dbline 147
 02F1           ;        LCD_display('A');
 02F1 CC0041            ldd #65
 02F4 16000C            jsr _LCD_display
 02F7                   .dbline 148
 02F7           ;        LCD_display('T');
 02F7 CC0054            ldd #84
 02FA 16000C            jsr _LCD_display
 02FD                   .dbline 149
 02FD           ;        LCD_display('U');
 02FD CC0055            ldd #85
 0300 16000C            jsr _LCD_display
 0303                   .dbline 150
 0303           ;        LCD_display('R');
 0303 CC0052            ldd #82
 0306 16000C            jsr _LCD_display
 0309                   .dbline 151
 0309           ;        LCD_display('E');
 0309 CC0045            ldd #69
 030C 16000C            jsr _LCD_display
 030F 203A              bra L85
 0311           L84:
 0311                   .dbline 154
 0311                   .dbline 155
 0311 EC18              ldd -8,x
 0313 CD000A            ldy #10
 0316 B7D6              exg x,y
 0318 1815              idivs
 031A B7D6              exg x,y
 031C 6C1C              std -4,x
 031E                   .dbline 156
 031E EC18              ldd -8,x
 0320 CD000A            ldy #10
 0323 B7D6              exg x,y
 0325 1815              idivs
 0327 B7D6              exg x,y
 0329 6D18              sty -8,x
 032B                   .dbline 157
 032B EC1C              ldd -4,x
 032D C30030            addd #48
 0330 6C1C              std -4,x
 0332                   .dbline 158
 0332 19E1EA            leay -22,x
 0335 6DE1E8            sty -24,x
 0338 EC1E              ldd -2,x
 033A 59                lsld
 033B E3E1E8            addd -24,x
 033E B7C6              xgdy
 0340 EC1C              ldd -4,x
 0342 6C40              std 0,y
 0344                   .dbline 159
 0344 EC1E              ldd -2,x
 0346 830001            subd #1
 0349 6C1E              std -2,x
 034B                   .dbline 160
 034B           L85:
 034B                   .dbline 153
 034B           ; 
 034B           ;        while (index>=0)
 034B EC1E              ldd -2,x
 034D 2CC2              bge L84
 034F                   .dbline 161
 034F           ;        {
 034F           ;                  remainder=holderTemp%10;
 034F           ;          holderTemp=holderTemp/10;
 034F           ;                  remainder=remainder+0x30;
 034F           ;                  arraycharstemp[index]=remainder;
 034F           ;                  index=index-1;
 034F           ;        } 
 034F           ;        LCD_display(' ');
 034F CC0020            ldd #32
 0352 16000C            jsr _LCD_display
 0355                   .dbline 162
 0355           ;        for(index=0;index<2;index++)
 0355 CC0000            ldd #0
 0358 6C1E              std -2,x
 035A           L87:
 035A                   .dbline 163
 035A                   .dbline 164
 035A 19E1EA            leay -22,x
 035D 6DE1E8            sty -24,x
 0360 EC1E              ldd -2,x
 0362 59                lsld
 0363 E3E1E8            addd -24,x
 0366 B7C6              xgdy
 0368 ED40              ldy 0,y
 036A 6D1A              sty -6,x
 036C                   .dbline 166
 036C EC1A              ldd -6,x
 036E 16000C            jsr _LCD_display
 0371                   .dbline 167
 0371           L88:
 0371                   .dbline 162
 0371 EC1E              ldd -2,x
 0373 C30001            addd #1
 0376 6C1E              std -2,x
 0378                   .dbline 162
 0378 EC1E              ldd -2,x
 037A 8C0002            cpd #2
 037D 2DDB              blt L87
 037F                   .dbline 169
 037F           ;        {
 037F           ;               number=arraycharstemp[index];
 037F           ; 
 037F           ;               LCD_display(number);
 037F           ;        }
 037F           ;        
 037F           ;        LCD_display('C');
 037F CC0043            ldd #67
 0382 16000C            jsr _LCD_display
 0385                   .dbline -2
 0385                   .dbline 170
 0385           ; }
 0385           L74:
 0385 B757              tfr x,s
 0387 30                pulx
 0388 1B82              leas 2,sp
 038A                   .dbline 0 ; func end
 038A 3D                rts
 038B                   .dbsym l arraycharstemp -22 A[4:2]I
 038B                   .dbsym l arraychars -18 A[8:4]I
 038B                   .dbsym l holderSpeed -10 I
 038B                   .dbsym l holderTemp -8 I
 038B                   .dbsym l number -6 I
 038B                   .dbsym l remainder -4 I
 038B                   .dbsym l index -2 I
 038B                   .dbsym l temp 6 I
 038B                   .dbsym l speed 2 I
 038B                   .dbend
 038B           L70:
 038B 4400              .byte 'D,0
 038D           L67:
 038D 4300              .byte 'C,0
 038F           L64:
 038F 4200              .byte 'B,0
 0391           L61:
 0391 4100              .byte 'A,0
 0393           L57:
 0393 4600              .byte 'F,0
 0395           L54:
 0395 3900              .byte 57,0
 0397           L51:
 0397 3600              .byte 54,0
 0399           L48:
 0399 3300              .byte 51,0
 039B           L44:
 039B 3000              .byte 48,0
 039D           L41:
 039D 3800              .byte 56,0
 039F           L38:
 039F 3500              .byte 53,0
 03A1           L35:
 03A1 3200              .byte 50,0
 03A3           L31:
 03A3 4500              .byte 'E,0
 03A5           L28:
 03A5 3700              .byte 55,0
 03A7           L25:
 03A7 3400              .byte 52,0
 03A9           L22:
 03A9 3100              .byte 49,0
